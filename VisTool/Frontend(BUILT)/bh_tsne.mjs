/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
/**
 * This is a fork of the Karpathy's TSNE.js (original license below).
 * This fork implements Barnes-Hut approximation and runs in O(NlogN)
 * time, as opposed to the Karpathy's O(N^2) version.
 *
 * Please refer to third_party/bh_tsne.LICENSE for the original license.
 *
 * @author smilkov@google.com (Daniel Smilkov)
 */
import { SPTree } from './sptree';
/**
 * Barnes-hut approximation level. Higher means more approximation and faster
 * results. Recommended value mentioned in the paper is 0.8.
 */
const THETA = 0.8;
const MIN_POSSIBLE_PROB = 1e-9;
// Variables used for memorizing the second random number since running
// gaussRandom() generates two random numbers at the cost of 1 atomic
// computation. This optimization results in 2X speed-up of the generator.
let return_v = false;
let v_val = 0;
/** Returns the square euclidean distance between two vectors. */
export function dist2(a, b) {
    if (a.length !== b.length) {
        throw new Error('Vectors a and b must be of same length');
    }
    let result = 0;
    for (let i = 0; i < a.length; ++i) {
        let diff = a[i] - b[i];
        result += diff * diff;
    }
    return result;
}
/** Returns the square euclidean distance between two 2D points. */
export function dist2_2D(a, b) {
    let dX = a[0] - b[0];
    let dY = a[1] - b[1];
    return dX * dX + dY * dY;
}
/** Returns the square euclidean distance between two 3D points. */
export function dist2_3D(a, b) {
    let dX = a[0] - b[0];
    let dY = a[1] - b[1];
    let dZ = a[2] - b[2];
    return dX * dX + dY * dY + dZ * dZ;
}
function gaussRandom(rng) {
    if (return_v) {
        return_v = false;
        return v_val;
    }
    let u = 2 * rng() - 1;
    let v = 2 * rng() - 1;
    let r = u * u + v * v;
    if (r === 0 || r > 1) {
        return gaussRandom(rng);
    }
    let c = Math.sqrt((-2 * Math.log(r)) / r);
    v_val = v * c; // cache this for next function call for efficiency
    return_v = true;
    return u * c;
}
// return random normal number
function randn(rng, mu, std) {
    return mu + gaussRandom(rng) * std;
}
// utilitity that creates contiguous vector of zeros of size n
function zeros(n) {
    return new Float64Array(n);
}
// utility that returns a matrix filled with random numbers
// generated by the provided generator.
function randnMatrix(n, d, rng) {
    let nd = n * d;
    let x = zeros(nd);
    for (let i = 0; i < nd; ++i) {
        x[i] = randn(rng, 0, 0.0001);
    }
    return x;
}
// utility that returns a matrix filled with the provided value.
function arrayofs(n, d, val) {
    let x = [];
    for (let i = 0; i < n; ++i) {
        x.push(d === 3 ? [val, val, val] : [val, val]);
    }
    return x;
}
// compute (p_{i|j} + p_{j|i})/(2n)
function nearest2P(nearest, perplexity, tol) {
    let N = nearest.length;
    let Htarget = Math.log(perplexity); // target entropy of distribution
    let P = zeros(N * N); // temporary probability matrix
    let K = nearest[0].length;
    let pRow = new Array(K); // pij[].
    for (let i = 0; i < N; ++i) {
        let neighbors = nearest[i];
        let betaMin = -Infinity;
        let betaMax = Infinity;
        let beta = 1; // initial value of precision
        let maxTries = 50;
        // perform binary search to find a suitable precision beta
        // so that the entropy of the distribution is appropriate
        let numTries = 0;
        while (true) {
            // compute entropy and kernel row with beta precision
            let psum = 0;
            for (let k = 0; k < neighbors.length; ++k) {
                let neighbor = neighbors[k];
                let pij = i === neighbor.index ? 0 : Math.exp(-neighbor.dist * beta);
                pij = Math.max(pij, MIN_POSSIBLE_PROB);
                pRow[k] = pij;
                psum += pij;
            }
            // normalize p and compute entropy
            let Hhere = 0;
            for (let k = 0; k < pRow.length; ++k) {
                pRow[k] /= psum;
                let pij = pRow[k];
                if (pij > 1e-7) {
                    Hhere -= pij * Math.log(pij);
                }
            }
            // adjust beta based on result
            if (Hhere > Htarget) {
                // entropy was too high (distribution too diffuse)
                // so we need to increase the precision for more peaky distribution
                betaMin = beta; // move up the bounds
                if (betaMax === Infinity) {
                    beta = beta * 2;
                }
                else {
                    beta = (beta + betaMax) / 2;
                }
            }
            else {
                // converse case. make distrubtion less peaky
                betaMax = beta;
                if (betaMin === -Infinity) {
                    beta = beta / 2;
                }
                else {
                    beta = (beta + betaMin) / 2;
                }
            }
            numTries++;
            // stopping conditions: too many tries or got a good precision
            if (numTries >= maxTries || Math.abs(Hhere - Htarget) < tol) {
                break;
            }
        }
        // copy over the final prow to P at row i
        for (let k = 0; k < pRow.length; ++k) {
            let pij = pRow[k];
            let j = neighbors[k].index;
            P[i * N + j] = pij;
        }
    } // end loop over examples i
    // symmetrize P and normalize it to sum to 1 over all ij
    let N2 = N * 2;
    for (let i = 0; i < N; ++i) {
        for (let j = i + 1; j < N; ++j) {
            let i_j = i * N + j;
            let j_i = j * N + i;
            let value = (P[i_j] + P[j_i]) / N2;
            P[i_j] = value;
            P[j_i] = value;
        }
    }
    return P;
}
// helper function
function sign(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
}
function computeForce_2d(force, mult, pointA, pointB) {
    force[0] += mult * (pointA[0] - pointB[0]);
    force[1] += mult * (pointA[1] - pointB[1]);
}
function computeForce_3d(force, mult, pointA, pointB) {
    force[0] += mult * (pointA[0] - pointB[0]);
    force[1] += mult * (pointA[1] - pointB[1]);
    force[2] += mult * (pointA[2] - pointB[2]);
}
export class TSNE {
    constructor(opt) {
        this.iter = 0;
        opt = opt || { dim: 2 };
        this.perplexity = opt.perplexity || 30;
        this.epsilon = opt.epsilon || 10;
        this.rng = opt.rng || Math.random;
        this.dim = opt.dim;
        if (opt.dim === 2) {
            this.dist2 = dist2_2D;
            this.computeForce = computeForce_2d;
        }
        else if (opt.dim === 3) {
            this.dist2 = dist2_3D;
            this.computeForce = computeForce_3d;
        }
        else {
            throw new Error('Only 2D and 3D is supported');
        }
    }
    // this function takes a fattened distance matrix and creates
    // matrix P from them.
    // D is assumed to be provided as an array of size N^2.
    initDataDist(nearest) {
        let N = nearest.length;
        this.nearest = nearest;
        this.P = nearest2P(nearest, this.perplexity, 0.0001);
        this.N = N;
        this.initSolution(); // refresh this
    }
    // (re)initializes the solution to random
    initSolution() {
        // generate random solution to t-SNE
        this.Y = randnMatrix(this.N, this.dim, this.rng); // the solution
        this.gains = arrayofs(this.N, this.dim, 1); // step gains
        // to accelerate progress in unchanging directions
        this.ystep = arrayofs(this.N, this.dim, 0); // momentum accumulator
        this.iter = 0;
    }
    getDim() {
        return this.dim;
    }
    // return pointer to current solution
    getSolution() {
        return this.Y;
    }
    // For each point, randomly offset point within a 5% hypersphere centered
    // around it, whilst remaining in the assumed t-SNE plot hypersphere
    perturb() {
        let N = this.N;
        let maxArea = 0;
        let ymean = this.dim === 3 ? [0, 0, 0] : [0, 0];
        // Determine radius of t-SNE hypersphere, assumed zero mean and normalized
        // dimensions. Here area is proportional to pi*radius^2, to skip root calc.
        for (let i = 0; i < N; ++i) {
            let area = 0;
            for (let d = 0; d < this.dim; ++d) {
                area += Math.pow(this.Y[i * this.dim + d], 2);
            }
            if (area > maxArea) {
                maxArea = area;
            }
        }
        let maxRadius = Math.pow(maxArea, 0.5);
        for (let i = 0; i < N; ++i) {
            let diff = new Array(this.dim);
            // Find a perturbation of point that fits inside t-SNE hypersphere
            while (true) {
                let area = 0;
                for (let d = 0; d < this.dim; ++d) {
                    diff[d] = 0.1 * maxRadius * (Math.random() - 0.5);
                    area += Math.pow(this.Y[i * this.dim + d] + diff[d], 2);
                }
                if (area < maxArea) {
                    break;
                }
            }
            // Apply offset to point
            for (let d = 0; d < this.dim; ++d) {
                this.Y[i * this.dim + d] += diff[d];
                ymean[d] += this.Y[i * this.dim + d];
            }
        }
        // reproject Y to be zero mean
        for (let i = 0; i < N; ++i) {
            for (let d = 0; d < this.dim; ++d) {
                this.Y[i * this.dim + d] -= ymean[d] / N;
            }
        }
    }
    // perform a single step of optimization to improve the embedding
    step() {
        this.iter += 1;
        let N = this.N;
        let grad = this.costGrad(this.Y); // evaluate gradient
        // perform gradient step
        let ymean = this.dim === 3 ? [0, 0, 0] : [0, 0];
        for (let i = 0; i < N; ++i) {
            for (let d = 0; d < this.dim; ++d) {
                let gid = grad[i][d];
                let sid = this.ystep[i][d];
                let gainid = this.gains[i][d];
                // compute gain update
                let newgain = sign(gid) === sign(sid) ? gainid * 0.8 : gainid + 0.2;
                if (newgain < 0.01) {
                    newgain = 0.01; // clamp
                }
                this.gains[i][d] = newgain; // store for next turn
                // compute momentum step direction
                let momval = this.iter < 250 ? 0.5 : 0.8;
                let newsid = momval * sid - this.epsilon * newgain * grad[i][d];
                this.ystep[i][d] = newsid; // remember the step we took
                // step!
                let i_d = i * this.dim + d;
                this.Y[i_d] += newsid;
                ymean[d] += this.Y[i_d]; // accumulate mean so that we
                // can center later
            }
        }
        // reproject Y to be zero mean
        for (let i = 0; i < N; ++i) {
            for (let d = 0; d < this.dim; ++d) {
                this.Y[i * this.dim + d] -= ymean[d] / N;
            }
        }
    }
    setSupervision(superviseLabels, superviseInput) {
        if (superviseLabels != null) {
            this.labels = superviseLabels;
            this.labelCounts = {};
            let uniqueEntries = Array.from(new Set(superviseLabels));
            uniqueEntries.forEach((l) => (this.labelCounts[l] = 0));
            superviseLabels.forEach((l) => (this.labelCounts[l] += 1));
        }
        if (superviseInput != null) {
            this.unlabeledClass = superviseInput;
        }
    }
    setSuperviseFactor(superviseFactor) {
        if (superviseFactor != null) {
            this.superviseFactor = superviseFactor;
        }
    }
    // return cost and gradient, given an arrangement
    costGrad(Y) {
        let N = this.N;
        let P = this.P;
        // Trick that helps with local optima.
        let alpha = this.iter < 100 ? 4 : 1;
        let superviseFactor = this.superviseFactor / 100; // set in range [0, 1]
        let unlabeledClass = this.unlabeledClass;
        let labels = this.labels;
        let labelCounts = this.labelCounts;
        let supervised = superviseFactor != null &&
            superviseFactor > 0 &&
            labels != null &&
            labelCounts != null;
        let unlabeledCount = supervised && unlabeledClass != null && unlabeledClass !== ''
            ? labelCounts[unlabeledClass]
            : 0;
        // Make data for the SP tree.
        let points = new Array(N); // (x, y)[]
        for (let i = 0; i < N; ++i) {
            let iTimesD = i * this.dim;
            let row = new Array(this.dim);
            for (let d = 0; d < this.dim; ++d) {
                row[d] = Y[iTimesD + d];
            }
            points[i] = row;
        }
        // Make a tree.
        let tree = new SPTree(points);
        let root = tree.root;
        // Annotate the tree.
        let annotateTree = (node) => {
            let numCells = 1;
            if (node.children == null) {
                // Update the current node and tell the parent.
                node.numCells = numCells;
                node.yCell = node.point;
                return { numCells, yCell: node.yCell };
            }
            // node.point is a 2 or 3-dim number[], so slice() makes a copy.
            let yCell = node.point.slice();
            for (let i = 0; i < node.children.length; ++i) {
                let child = node.children[i];
                if (child == null) {
                    continue;
                }
                let result = annotateTree(child);
                numCells += result.numCells;
                for (let d = 0; d < this.dim; ++d) {
                    yCell[d] += result.yCell[d];
                }
            }
            // Update the node and tell the parent.
            node.numCells = numCells;
            node.yCell = yCell.map((v) => v / numCells);
            return { numCells, yCell };
        };
        // Augment the tree with more info.
        annotateTree(root);
        tree.visit((node, low, high) => {
            node.rCell = high[0] - low[0];
            return false;
        });
        // compute current Q distribution, unnormalized first
        let grad = [];
        let Z = 0;
        let sum_pij = 0;
        let forces = new Array(N);
        for (let i = 0; i < N; ++i) {
            let pointI = points[i];
            if (supervised) {
                var sameCount = labelCounts[labels[i]];
                var otherCount = N - sameCount - unlabeledCount;
            }
            // Compute the positive forces for the i-th node.
            let Fpos = this.dim === 3 ? [0, 0, 0] : [0, 0];
            let neighbors = this.nearest[i];
            for (let k = 0; k < neighbors.length; ++k) {
                let j = neighbors[k].index;
                let pij = P[i * N + j];
                // apply semi-supervised prior probabilities
                if (supervised) {
                    if (labels[i] === unlabeledClass || labels[j] === unlabeledClass) {
                        pij *= 1 / N;
                    }
                    else if (labels[i] !== labels[j]) {
                        pij *= Math.max(1 / N - superviseFactor / otherCount, 1e-7);
                    }
                    else if (labels[i] === labels[j]) {
                        pij *= Math.min(1 / N + superviseFactor / sameCount, 1 - 1e-7);
                    }
                    sum_pij += pij;
                }
                let pointJ = points[j];
                let squaredDistItoJ = this.dist2(pointI, pointJ);
                let premult = pij / (1 + squaredDistItoJ);
                this.computeForce(Fpos, premult, pointI, pointJ);
            }
            // Compute the negative forces for the i-th node.
            let FnegZ = this.dim === 3 ? [0, 0, 0] : [0, 0];
            tree.visit((node) => {
                let squaredDistToCell = this.dist2(pointI, node.yCell);
                // Squared distance from point i to cell.
                if (node.children == null ||
                    (squaredDistToCell > 0 &&
                        node.rCell / Math.sqrt(squaredDistToCell) < THETA)) {
                    let qijZ = 1 / (1 + squaredDistToCell);
                    let dZ = node.numCells * qijZ;
                    Z += dZ;
                    dZ *= qijZ;
                    this.computeForce(FnegZ, dZ, pointI, node.yCell);
                    return true;
                }
                // Cell is too close to approximate.
                let squaredDistToPoint = this.dist2(pointI, node.point);
                let qijZ = 1 / (1 + squaredDistToPoint);
                Z += qijZ;
                qijZ *= qijZ;
                this.computeForce(FnegZ, qijZ, pointI, node.point);
                return false;
            }, true);
            forces[i] = [Fpos, FnegZ];
        }
        // Normalize the negative forces and compute the gradient.
        let A = 4 * alpha;
        if (supervised) {
            A /= sum_pij;
        }
        const B = 4 / Z;
        for (let i = 0; i < N; ++i) {
            let [FPos, FNegZ] = forces[i];
            let gsum = new Array(this.dim);
            for (let d = 0; d < this.dim; ++d) {
                gsum[d] = A * FPos[d] - B * FNegZ[d];
            }
            grad.push(gsum);
        }
        return grad;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmhfdHNuZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RlbnNvcmJvYXJkL3Byb2plY3Rvci9iaF90c25lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O2dGQWFnRjtBQUNoRjs7Ozs7Ozs7R0FRRztBQUVILE9BQU8sRUFBUyxNQUFNLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFPeEM7OztHQUdHO0FBQ0gsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDO0FBQ2xCLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDO0FBQy9CLHVFQUF1RTtBQUN2RSxxRUFBcUU7QUFDckUsMEVBQTBFO0FBQzFFLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztBQUNyQixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZCxpRUFBaUU7QUFDakUsTUFBTSxVQUFVLEtBQUssQ0FBQyxDQUFXLEVBQUUsQ0FBVztJQUM1QyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7S0FDM0Q7SUFDRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDZixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNqQyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLE1BQU0sSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQ3ZCO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUNELG1FQUFtRTtBQUNuRSxNQUFNLFVBQVUsUUFBUSxDQUFDLENBQVcsRUFBRSxDQUFXO0lBQy9DLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxD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QUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RDO1lBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyogQ29weXJpZ2h0IDIwMTYgVGhlIFRlbnNvckZsb3cgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyoqXG4gKiBUaGlzIGlzIGEgZm9yayBvZiB0aGUgS2FycGF0aHkncyBUU05FLmpzIChvcmlnaW5hbCBsaWNlbnNlIGJlbG93KS5cbiAqIFRoaXMgZm9yayBpbXBsZW1lbnRzIEJhcm5lcy1IdXQgYXBwcm94aW1hdGlvbiBhbmQgcnVucyBpbiBPKE5sb2dOKVxuICogdGltZSwgYXMgb3Bwb3NlZCB0byB0aGUgS2FycGF0aHkncyBPKE5eMikgdmVyc2lvbi5cbiAqXG4gKiBQbGVhc2UgcmVmZXIgdG8gdGhpcmRfcGFydHkvYmhfdHNuZS5MSUNFTlNFIGZvciB0aGUgb3JpZ2luYWwgbGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIHNtaWxrb3ZAZ29vZ2xlLmNvbSAoRGFuaWVsIFNtaWxrb3YpXG4gKi9cblxuaW1wb3J0IHtTUE5vZGUsIFNQVHJlZX0gZnJvbSAnLi9zcHRyZWUnO1xuXG50eXBlIEF1Z21TUE5vZGUgPSBTUE5vZGUgJiB7XG4gIG51bUNlbGxzOiBudW1iZXI7XG4gIHlDZWxsOiBudW1iZXJbXTtcbiAgckNlbGw6IG51bWJlcjtcbn07XG4vKipcbiAqIEJhcm5lcy1odXQgYXBwcm94aW1hdGlvbiBsZXZlbC4gSGlnaGVyIG1lYW5zIG1vcmUgYXBwcm94aW1hdGlvbiBhbmQgZmFzdGVyXG4gKiByZXN1bHRzLiBSZWNvbW1lbmRlZCB2YWx1ZSBtZW50aW9uZWQgaW4gdGhlIHBhcGVyIGlzIDAuOC5cbiAqL1xuY29uc3QgVEhFVEEgPSAwLjg7XG5jb25zdCBNSU5fUE9TU0lCTEVfUFJPQiA9IDFlLTk7XG4vLyBWYXJpYWJsZXMgdXNlZCBmb3IgbWVtb3JpemluZyB0aGUgc2Vjb25kIHJhbmRvbSBudW1iZXIgc2luY2UgcnVubmluZ1xuLy8gZ2F1c3NSYW5kb20oKSBnZW5lcmF0ZXMgdHdvIHJhbmRvbSBudW1iZXJzIGF0IHRoZSBjb3N0IG9mIDEgYXRvbWljXG4vLyBjb21wdXRhdGlvbi4gVGhpcyBvcHRpbWl6YXRpb24gcmVzdWx0cyBpbiAyWCBzcGVlZC11cCBvZiB0aGUgZ2VuZXJhdG9yLlxubGV0IHJldHVybl92ID0gZmFsc2U7XG5sZXQgdl92YWwgPSAwO1xuLyoqIFJldHVybnMgdGhlIHNxdWFyZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjdG9ycy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0MihhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWZWN0b3JzIGEgYW5kIGIgbXVzdCBiZSBvZiBzYW1lIGxlbmd0aCcpO1xuICB9XG4gIGxldCByZXN1bHQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgZGlmZiA9IGFbaV0gLSBiW2ldO1xuICAgIHJlc3VsdCArPSBkaWZmICogZGlmZjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIFJldHVybnMgdGhlIHNxdWFyZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gMkQgcG9pbnRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3QyXzJEKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGxldCBkWCA9IGFbMF0gLSBiWzBdO1xuICBsZXQgZFkgPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIGRYICogZFggKyBkWSAqIGRZO1xufVxuLyoqIFJldHVybnMgdGhlIHNxdWFyZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gM0QgcG9pbnRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3QyXzNEKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGxldCBkWCA9IGFbMF0gLSBiWzBdO1xuICBsZXQgZFkgPSBhWzFdIC0gYlsxXTtcbiAgbGV0IGRaID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBkWCAqIGRYICsgZFkgKiBkWSArIGRaICogZFo7XG59XG5mdW5jdGlvbiBnYXVzc1JhbmRvbShybmc6ICgpID0+IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChyZXR1cm5fdikge1xuICAgIHJldHVybl92ID0gZmFsc2U7XG4gICAgcmV0dXJuIHZfdmFsO1xuICB9XG4gIGxldCB1ID0gMiAqIHJuZygpIC0gMTtcbiAgbGV0IHYgPSAyICogcm5nKCkgLSAxO1xuICBsZXQgciA9IHUgKiB1ICsgdiAqIHY7XG4gIGlmIChyID09PSAwIHx8IHIgPiAxKSB7XG4gICAgcmV0dXJuIGdhdXNzUmFuZG9tKHJuZyk7XG4gIH1cbiAgbGV0IGMgPSBNYXRoLnNxcnQoKC0yICogTWF0aC5sb2cocikpIC8gcik7XG4gIHZfdmFsID0gdiAqIGM7IC8vIGNhY2hlIHRoaXMgZm9yIG5leHQgZnVuY3Rpb24gY2FsbCBmb3IgZWZmaWNpZW5jeVxuICByZXR1cm5fdiA9IHRydWU7XG4gIHJldHVybiB1ICogYztcbn1cbi8vIHJldHVybiByYW5kb20gbm9ybWFsIG51bWJlclxuZnVuY3Rpb24gcmFuZG4ocm5nOiAoKSA9PiBudW1iZXIsIG11OiBudW1iZXIsIHN0ZDogbnVtYmVyKSB7XG4gIHJldHVybiBtdSArIGdhdXNzUmFuZG9tKHJuZykgKiBzdGQ7XG59XG4vLyB1dGlsaXRpdHkgdGhhdCBjcmVhdGVzIGNvbnRpZ3VvdXMgdmVjdG9yIG9mIHplcm9zIG9mIHNpemUgblxuZnVuY3Rpb24gemVyb3MobjogbnVtYmVyKTogRmxvYXQ2NEFycmF5IHtcbiAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobik7XG59XG4vLyB1dGlsaXR5IHRoYXQgcmV0dXJucyBhIG1hdHJpeCBmaWxsZWQgd2l0aCByYW5kb20gbnVtYmVyc1xuLy8gZ2VuZXJhdGVkIGJ5IHRoZSBwcm92aWRlZCBnZW5lcmF0b3IuXG5mdW5jdGlvbiByYW5kbk1hdHJpeChuOiBudW1iZXIsIGQ6IG51bWJlciwgcm5nOiAoKSA9PiBudW1iZXIpIHtcbiAgbGV0IG5kID0gbiAqIGQ7XG4gIGxldCB4ID0gemVyb3MobmQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5kOyArK2kpIHtcbiAgICB4W2ldID0gcmFuZG4ocm5nLCAwLCAwLjAwMDEpO1xuICB9XG4gIHJldHVybiB4O1xufVxuLy8gdXRpbGl0eSB0aGF0IHJldHVybnMgYSBtYXRyaXggZmlsbGVkIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLlxuZnVuY3Rpb24gYXJyYXlvZnMobjogbnVtYmVyLCBkOiBudW1iZXIsIHZhbDogbnVtYmVyKSB7XG4gIGxldCB4OiBudW1iZXJbXVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgeC5wdXNoKGQgPT09IDMgPyBbdmFsLCB2YWwsIHZhbF0gOiBbdmFsLCB2YWxdKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbi8vIGNvbXB1dGUgKHBfe2l8an0gKyBwX3tqfGl9KS8oMm4pXG5mdW5jdGlvbiBuZWFyZXN0MlAoXG4gIG5lYXJlc3Q6IHtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIGRpc3Q6IG51bWJlcjtcbiAgfVtdW10sXG4gIHBlcnBsZXhpdHk6IG51bWJlcixcbiAgdG9sOiBudW1iZXJcbikge1xuICBsZXQgTiA9IG5lYXJlc3QubGVuZ3RoO1xuICBsZXQgSHRhcmdldCA9IE1hdGgubG9nKHBlcnBsZXhpdHkpOyAvLyB0YXJnZXQgZW50cm9weSBvZiBkaXN0cmlidXRpb25cbiAgbGV0IFAgPSB6ZXJvcyhOICogTik7IC8vIHRlbXBvcmFyeSBwcm9iYWJpbGl0eSBtYXRyaXhcbiAgbGV0IEsgPSBuZWFyZXN0WzBdLmxlbmd0aDtcbiAgbGV0IHBSb3c6IG51bWJlcltdID0gbmV3IEFycmF5KEspOyAvLyBwaWpbXS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBsZXQgbmVpZ2hib3JzID0gbmVhcmVzdFtpXTtcbiAgICBsZXQgYmV0YU1pbiA9IC1JbmZpbml0eTtcbiAgICBsZXQgYmV0YU1heCA9IEluZmluaXR5O1xuICAgIGxldCBiZXRhID0gMTsgLy8gaW5pdGlhbCB2YWx1ZSBvZiBwcmVjaXNpb25cbiAgICBsZXQgbWF4VHJpZXMgPSA1MDtcbiAgICAvLyBwZXJmb3JtIGJpbmFyeSBzZWFyY2ggdG8gZmluZCBhIHN1aXRhYmxlIHByZWNpc2lvbiBiZXRhXG4gICAgLy8gc28gdGhhdCB0aGUgZW50cm9weSBvZiB0aGUgZGlzdHJpYnV0aW9uIGlzIGFwcHJvcHJpYXRlXG4gICAgbGV0IG51bVRyaWVzID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gY29tcHV0ZSBlbnRyb3B5IGFuZCBrZXJuZWwgcm93IHdpdGggYmV0YSBwcmVjaXNpb25cbiAgICAgIGxldCBwc3VtID0gMDtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbmVpZ2hib3JzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxldCBuZWlnaGJvciA9IG5laWdoYm9yc1trXTtcbiAgICAgICAgbGV0IHBpaiA9IGkgPT09IG5laWdoYm9yLmluZGV4ID8gMCA6IE1hdGguZXhwKC1uZWlnaGJvci5kaXN0ICogYmV0YSk7XG4gICAgICAgIHBpaiA9IE1hdGgubWF4KHBpaiwgTUlOX1BPU1NJQkxFX1BST0IpO1xuICAgICAgICBwUm93W2tdID0gcGlqO1xuICAgICAgICBwc3VtICs9IHBpajtcbiAgICAgIH1cbiAgICAgIC8vIG5vcm1hbGl6ZSBwIGFuZCBjb21wdXRlIGVudHJvcHlcbiAgICAgIGxldCBIaGVyZSA9IDA7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHBSb3cubGVuZ3RoOyArK2spIHtcbiAgICAgICAgcFJvd1trXSAvPSBwc3VtO1xuICAgICAgICBsZXQgcGlqID0gcFJvd1trXTtcbiAgICAgICAgaWYgKHBpaiA+IDFlLTcpIHtcbiAgICAgICAgICBIaGVyZSAtPSBwaWogKiBNYXRoLmxvZyhwaWopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgYmV0YSBiYXNlZCBvbiByZXN1bHRcbiAgICAgIGlmIChIaGVyZSA+IEh0YXJnZXQpIHtcbiAgICAgICAgLy8gZW50cm9weSB3YXMgdG9vIGhpZ2ggKGRpc3RyaWJ1dGlvbiB0b28gZGlmZnVzZSlcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBpbmNyZWFzZSB0aGUgcHJlY2lzaW9uIGZvciBtb3JlIHBlYWt5IGRpc3RyaWJ1dGlvblxuICAgICAgICBiZXRhTWluID0gYmV0YTsgLy8gbW92ZSB1cCB0aGUgYm91bmRzXG4gICAgICAgIGlmIChiZXRhTWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIGJldGEgPSBiZXRhICogMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZXRhID0gKGJldGEgKyBiZXRhTWF4KSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnZlcnNlIGNhc2UuIG1ha2UgZGlzdHJ1YnRpb24gbGVzcyBwZWFreVxuICAgICAgICBiZXRhTWF4ID0gYmV0YTtcbiAgICAgICAgaWYgKGJldGFNaW4gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIGJldGEgPSBiZXRhIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZXRhID0gKGJldGEgKyBiZXRhTWluKSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG51bVRyaWVzKys7XG4gICAgICAvLyBzdG9wcGluZyBjb25kaXRpb25zOiB0b28gbWFueSB0cmllcyBvciBnb3QgYSBnb29kIHByZWNpc2lvblxuICAgICAgaWYgKG51bVRyaWVzID49IG1heFRyaWVzIHx8IE1hdGguYWJzKEhoZXJlIC0gSHRhcmdldCkgPCB0b2wpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvcHkgb3ZlciB0aGUgZmluYWwgcHJvdyB0byBQIGF0IHJvdyBpXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBwUm93Lmxlbmd0aDsgKytrKSB7XG4gICAgICBsZXQgcGlqID0gcFJvd1trXTtcbiAgICAgIGxldCBqID0gbmVpZ2hib3JzW2tdLmluZGV4O1xuICAgICAgUFtpICogTiArIGpdID0gcGlqO1xuICAgIH1cbiAgfSAvLyBlbmQgbG9vcCBvdmVyIGV4YW1wbGVzIGlcbiAgLy8gc3ltbWV0cml6ZSBQIGFuZCBub3JtYWxpemUgaXQgdG8gc3VtIHRvIDEgb3ZlciBhbGwgaWpcbiAgbGV0IE4yID0gTiAqIDI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICBsZXQgaV9qID0gaSAqIE4gKyBqO1xuICAgICAgbGV0IGpfaSA9IGogKiBOICsgaTtcbiAgICAgIGxldCB2YWx1ZSA9IChQW2lfal0gKyBQW2pfaV0pIC8gTjI7XG4gICAgICBQW2lfal0gPSB2YWx1ZTtcbiAgICAgIFBbal9pXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUDtcbn1cbi8vIGhlbHBlciBmdW5jdGlvblxuZnVuY3Rpb24gc2lnbih4OiBudW1iZXIpIHtcbiAgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZvcmNlXzJkKFxuICBmb3JjZTogbnVtYmVyW10sXG4gIG11bHQ6IG51bWJlcixcbiAgcG9pbnRBOiBudW1iZXJbXSxcbiAgcG9pbnRCOiBudW1iZXJbXVxuKSB7XG4gIGZvcmNlWzBdICs9IG11bHQgKiAocG9pbnRBWzBdIC0gcG9pbnRCWzBdKTtcbiAgZm9yY2VbMV0gKz0gbXVsdCAqIChwb2ludEFbMV0gLSBwb2ludEJbMV0pO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZvcmNlXzNkKFxuICBmb3JjZTogbnVtYmVyW10sXG4gIG11bHQ6IG51bWJlcixcbiAgcG9pbnRBOiBudW1iZXJbXSxcbiAgcG9pbnRCOiBudW1iZXJbXVxuKSB7XG4gIGZvcmNlWzBdICs9IG11bHQgKiAocG9pbnRBWzBdIC0gcG9pbnRCWzBdKTtcbiAgZm9yY2VbMV0gKz0gbXVsdCAqIChwb2ludEFbMV0gLSBwb2ludEJbMV0pO1xuICBmb3JjZVsyXSArPSBtdWx0ICogKHBvaW50QVsyXSAtIHBvaW50QlsyXSk7XG59XG5leHBvcnQgaW50ZXJmYWNlIFRTTkVPcHRpb25zIHtcbiAgLyoqIEhvdyBtYW55IGRpbWVuc2lvbnMuICovXG4gIGRpbTogbnVtYmVyO1xuICAvKiogUm91Z2hseSBob3cgbWFueSBuZWlnaGJvcnMgZWFjaCBwb2ludCBpbmZsdWVuY2VzLiAqL1xuICBwZXJwbGV4aXR5PzogbnVtYmVyO1xuICAvKiogTGVhcm5pbmcgcmF0ZS4gKi9cbiAgZXBzaWxvbj86IG51bWJlcjtcbiAgLyoqIEEgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuICovXG4gIHJuZz86ICgpID0+IG51bWJlcjtcbn1cbmV4cG9ydCBjbGFzcyBUU05FIHtcbiAgcHJpdmF0ZSBwZXJwbGV4aXR5OiBudW1iZXI7XG4gIHByaXZhdGUgZXBzaWxvbjogbnVtYmVyO1xuICBwcml2YXRlIHN1cGVydmlzZUZhY3RvcjogbnVtYmVyO1xuICBwcml2YXRlIHVubGFiZWxlZENsYXNzOiBzdHJpbmc7XG4gIHByaXZhdGUgbGFiZWxzOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBsYWJlbENvdW50czoge1xuICAgIFtrZXk6IHN0cmluZ106IG51bWJlcjtcbiAgfTtcbiAgLyoqIFJhbmRvbSBnZW5lcmF0b3IgKi9cbiAgcHJpdmF0ZSBybmc6ICgpID0+IG51bWJlcjtcbiAgcHJpdmF0ZSBpdGVyID0gMDtcbiAgcHJpdmF0ZSBZOiBGbG9hdDY0QXJyYXk7XG4gIHByaXZhdGUgTjogbnVtYmVyO1xuICBwcml2YXRlIFA6IEZsb2F0NjRBcnJheTtcbiAgcHJpdmF0ZSBnYWluczogbnVtYmVyW11bXTtcbiAgcHJpdmF0ZSB5c3RlcDogbnVtYmVyW11bXTtcbiAgcHJpdmF0ZSBuZWFyZXN0OiB7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICBkaXN0OiBudW1iZXI7XG4gIH1bXVtdO1xuICBwcml2YXRlIGRpbTogbnVtYmVyO1xuICBwcml2YXRlIGRpc3QyOiAoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKSA9PiBudW1iZXI7XG4gIHByaXZhdGUgY29tcHV0ZUZvcmNlOiAoXG4gICAgZm9yY2U6IG51bWJlcltdLFxuICAgIG11bHQ6IG51bWJlcixcbiAgICBwb2ludEE6IG51bWJlcltdLFxuICAgIHBvaW50QjogbnVtYmVyW11cbiAgKSA9PiB2b2lkO1xuICBjb25zdHJ1Y3RvcihvcHQ6IFRTTkVPcHRpb25zKSB7XG4gICAgb3B0ID0gb3B0IHx8IHtkaW06IDJ9O1xuICAgIHRoaXMucGVycGxleGl0eSA9IG9wdC5wZXJwbGV4aXR5IHx8IDMwO1xuICAgIHRoaXMuZXBzaWxvbiA9IG9wdC5lcHNpbG9uIHx8IDEwO1xuICAgIHRoaXMucm5nID0gb3B0LnJuZyB8fCBNYXRoLnJhbmRvbTtcbiAgICB0aGlzLmRpbSA9IG9wdC5kaW07XG4gICAgaWYgKG9wdC5kaW0gPT09IDIpIHtcbiAgICAgIHRoaXMuZGlzdDIgPSBkaXN0Ml8yRDtcbiAgICAgIHRoaXMuY29tcHV0ZUZvcmNlID0gY29tcHV0ZUZvcmNlXzJkO1xuICAgIH0gZWxzZSBpZiAob3B0LmRpbSA9PT0gMykge1xuICAgICAgdGhpcy5kaXN0MiA9IGRpc3QyXzNEO1xuICAgICAgdGhpcy5jb21wdXRlRm9yY2UgPSBjb21wdXRlRm9yY2VfM2Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSAyRCBhbmQgM0QgaXMgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG4gIC8vIHRoaXMgZnVuY3Rpb24gdGFrZXMgYSBmYXR0ZW5lZCBkaXN0YW5jZSBtYXRyaXggYW5kIGNyZWF0ZXNcbiAgLy8gbWF0cml4IFAgZnJvbSB0aGVtLlxuICAvLyBEIGlzIGFzc3VtZWQgdG8gYmUgcHJvdmlkZWQgYXMgYW4gYXJyYXkgb2Ygc2l6ZSBOXjIuXG4gIGluaXREYXRhRGlzdChcbiAgICBuZWFyZXN0OiB7XG4gICAgICBpbmRleDogbnVtYmVyO1xuICAgICAgZGlzdDogbnVtYmVyO1xuICAgIH1bXVtdXG4gICkge1xuICAgIGxldCBOID0gbmVhcmVzdC5sZW5ndGg7XG4gICAgdGhpcy5uZWFyZXN0ID0gbmVhcmVzdDtcbiAgICB0aGlzLlAgPSBuZWFyZXN0MlAobmVhcmVzdCwgdGhpcy5wZXJwbGV4aXR5LCAwLjAwMDEpO1xuICAgIHRoaXMuTiA9IE47XG4gICAgdGhpcy5pbml0U29sdXRpb24oKTsgLy8gcmVmcmVzaCB0aGlzXG4gIH1cbiAgLy8gKHJlKWluaXRpYWxpemVzIHRoZSBzb2x1dGlvbiB0byByYW5kb21cbiAgaW5pdFNvbHV0aW9uKCkge1xuICAgIC8vIGdlbmVyYXRlIHJhbmRvbSBzb2x1dGlvbiB0byB0LVNORVxuICAgIHRoaXMuWSA9IHJhbmRuTWF0cml4KHRoaXMuTiwgdGhpcy5kaW0sIHRoaXMucm5nKTsgLy8gdGhlIHNvbHV0aW9uXG4gICAgdGhpcy5nYWlucyA9IGFycmF5b2ZzKHRoaXMuTiwgdGhpcy5kaW0sIDEpOyAvLyBzdGVwIGdhaW5zXG4gICAgLy8gdG8gYWNjZWxlcmF0ZSBwcm9ncmVzcyBpbiB1bmNoYW5naW5nIGRpcmVjdGlvbnNcbiAgICB0aGlzLnlzdGVwID0gYXJyYXlvZnModGhpcy5OLCB0aGlzLmRpbSwgMCk7IC8vIG1vbWVudHVtIGFjY3VtdWxhdG9yXG4gICAgdGhpcy5pdGVyID0gMDtcbiAgfVxuICBnZXREaW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltO1xuICB9XG4gIC8vIHJldHVybiBwb2ludGVyIHRvIGN1cnJlbnQgc29sdXRpb25cbiAgZ2V0U29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuWTtcbiAgfVxuICAvLyBGb3IgZWFjaCBwb2ludCwgcmFuZG9tbHkgb2Zmc2V0IHBvaW50IHdpdGhpbiBhIDUlIGh5cGVyc3BoZXJlIGNlbnRlcmVkXG4gIC8vIGFyb3VuZCBpdCwgd2hpbHN0IHJlbWFpbmluZyBpbiB0aGUgYXNzdW1lZCB0LVNORSBwbG90IGh5cGVyc3BoZXJlXG4gIHBlcnR1cmIoKSB7XG4gICAgbGV0IE4gPSB0aGlzLk47XG4gICAgbGV0IG1heEFyZWEgPSAwO1xuICAgIGxldCB5bWVhbiA9IHRoaXMuZGltID09PSAzID8gWzAsIDAsIDBdIDogWzAsIDBdO1xuICAgIC8vIERldGVybWluZSByYWRpdXMgb2YgdC1TTkUgaHlwZXJzcGhlcmUsIGFzc3VtZWQgemVybyBtZWFuIGFuZCBub3JtYWxpemVkXG4gICAgLy8gZGltZW5zaW9ucy4gSGVyZSBhcmVhIGlzIHByb3BvcnRpb25hbCB0byBwaSpyYWRpdXNeMiwgdG8gc2tpcCByb290IGNhbGMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGxldCBhcmVhID0gMDtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICBhcmVhICs9IE1hdGgucG93KHRoaXMuWVtpICogdGhpcy5kaW0gKyBkXSwgMik7XG4gICAgICB9XG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXhSYWRpdXMgPSBNYXRoLnBvdyhtYXhBcmVhLCAwLjUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICBsZXQgZGlmZiA9IG5ldyBBcnJheSh0aGlzLmRpbSk7XG4gICAgICAvLyBGaW5kIGEgcGVydHVyYmF0aW9uIG9mIHBvaW50IHRoYXQgZml0cyBpbnNpZGUgdC1TTkUgaHlwZXJzcGhlcmVcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBhcmVhID0gMDtcbiAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLmRpbTsgKytkKSB7XG4gICAgICAgICAgZGlmZltkXSA9IDAuMSAqIG1heFJhZGl1cyAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICAgICAgICBhcmVhICs9IE1hdGgucG93KHRoaXMuWVtpICogdGhpcy5kaW0gKyBkXSArIGRpZmZbZF0sIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmVhIDwgbWF4QXJlYSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBcHBseSBvZmZzZXQgdG8gcG9pbnRcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICB0aGlzLllbaSAqIHRoaXMuZGltICsgZF0gKz0gZGlmZltkXTtcbiAgICAgICAgeW1lYW5bZF0gKz0gdGhpcy5ZW2kgKiB0aGlzLmRpbSArIGRdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXByb2plY3QgWSB0byBiZSB6ZXJvIG1lYW5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLmRpbTsgKytkKSB7XG4gICAgICAgIHRoaXMuWVtpICogdGhpcy5kaW0gKyBkXSAtPSB5bWVhbltkXSAvIE47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHBlcmZvcm0gYSBzaW5nbGUgc3RlcCBvZiBvcHRpbWl6YXRpb24gdG8gaW1wcm92ZSB0aGUgZW1iZWRkaW5nXG4gIHN0ZXAoKSB7XG4gICAgdGhpcy5pdGVyICs9IDE7XG4gICAgbGV0IE4gPSB0aGlzLk47XG4gICAgbGV0IGdyYWQgPSB0aGlzLmNvc3RHcmFkKHRoaXMuWSk7IC8vIGV2YWx1YXRlIGdyYWRpZW50XG4gICAgLy8gcGVyZm9ybSBncmFkaWVudCBzdGVwXG4gICAgbGV0IHltZWFuID0gdGhpcy5kaW0gPT09IDMgPyBbMCwgMCwgMF0gOiBbMCwgMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICBsZXQgZ2lkID0gZ3JhZFtpXVtkXTtcbiAgICAgICAgbGV0IHNpZCA9IHRoaXMueXN0ZXBbaV1bZF07XG4gICAgICAgIGxldCBnYWluaWQgPSB0aGlzLmdhaW5zW2ldW2RdO1xuICAgICAgICAvLyBjb21wdXRlIGdhaW4gdXBkYXRlXG4gICAgICAgIGxldCBuZXdnYWluID0gc2lnbihnaWQpID09PSBzaWduKHNpZCkgPyBnYWluaWQgKiAwLjggOiBnYWluaWQgKyAwLjI7XG4gICAgICAgIGlmIChuZXdnYWluIDwgMC4wMSkge1xuICAgICAgICAgIG5ld2dhaW4gPSAwLjAxOyAvLyBjbGFtcFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2FpbnNbaV1bZF0gPSBuZXdnYWluOyAvLyBzdG9yZSBmb3IgbmV4dCB0dXJuXG4gICAgICAgIC8vIGNvbXB1dGUgbW9tZW50dW0gc3RlcCBkaXJlY3Rpb25cbiAgICAgICAgbGV0IG1vbXZhbCA9IHRoaXMuaXRlciA8IDI1MCA/IDAuNSA6IDAuODtcbiAgICAgICAgbGV0IG5ld3NpZCA9IG1vbXZhbCAqIHNpZCAtIHRoaXMuZXBzaWxvbiAqIG5ld2dhaW4gKiBncmFkW2ldW2RdO1xuICAgICAgICB0aGlzLnlzdGVwW2ldW2RdID0gbmV3c2lkOyAvLyByZW1lbWJlciB0aGUgc3RlcCB3ZSB0b29rXG4gICAgICAgIC8vIHN0ZXAhXG4gICAgICAgIGxldCBpX2QgPSBpICogdGhpcy5kaW0gKyBkO1xuICAgICAgICB0aGlzLllbaV9kXSArPSBuZXdzaWQ7XG4gICAgICAgIHltZWFuW2RdICs9IHRoaXMuWVtpX2RdOyAvLyBhY2N1bXVsYXRlIG1lYW4gc28gdGhhdCB3ZVxuICAgICAgICAvLyBjYW4gY2VudGVyIGxhdGVyXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlcHJvamVjdCBZIHRvIGJlIHplcm8gbWVhblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHRoaXMuZGltOyArK2QpIHtcbiAgICAgICAgdGhpcy5ZW2kgKiB0aGlzLmRpbSArIGRdIC09IHltZWFuW2RdIC8gTjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0U3VwZXJ2aXNpb24oc3VwZXJ2aXNlTGFiZWxzOiBzdHJpbmdbXSwgc3VwZXJ2aXNlSW5wdXQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoc3VwZXJ2aXNlTGFiZWxzICE9IG51bGwpIHtcbiAgICAgIHRoaXMubGFiZWxzID0gc3VwZXJ2aXNlTGFiZWxzO1xuICAgICAgdGhpcy5sYWJlbENvdW50cyA9IHt9O1xuICAgICAgbGV0IHVuaXF1ZUVudHJpZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc3VwZXJ2aXNlTGFiZWxzKSk7XG4gICAgICB1bmlxdWVFbnRyaWVzLmZvckVhY2goKGwpID0+ICh0aGlzLmxhYmVsQ291bnRzW2xdID0gMCkpO1xuICAgICAgc3VwZXJ2aXNlTGFiZWxzLmZvckVhY2goKGwpID0+ICh0aGlzLmxhYmVsQ291bnRzW2xdICs9IDEpKTtcbiAgICB9XG4gICAgaWYgKHN1cGVydmlzZUlucHV0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMudW5sYWJlbGVkQ2xhc3MgPSBzdXBlcnZpc2VJbnB1dDtcbiAgICB9XG4gIH1cbiAgc2V0U3VwZXJ2aXNlRmFjdG9yKHN1cGVydmlzZUZhY3RvcjogbnVtYmVyKSB7XG4gICAgaWYgKHN1cGVydmlzZUZhY3RvciAhPSBudWxsKSB7XG4gICAgICB0aGlzLnN1cGVydmlzZUZhY3RvciA9IHN1cGVydmlzZUZhY3RvcjtcbiAgICB9XG4gIH1cbiAgLy8gcmV0dXJuIGNvc3QgYW5kIGdyYWRpZW50LCBnaXZlbiBhbiBhcnJhbmdlbWVudFxuICBjb3N0R3JhZChZOiBGbG9hdDY0QXJyYXkpOiBudW1iZXJbXVtdIHtcbiAgICBsZXQgTiA9IHRoaXMuTjtcbiAgICBsZXQgUCA9IHRoaXMuUDtcbiAgICAvLyBUcmljayB0aGF0IGhlbHBzIHdpdGggbG9jYWwgb3B0aW1hLlxuICAgIGxldCBhbHBoYSA9IHRoaXMuaXRlciA8IDEwMCA/IDQgOiAxO1xuICAgIGxldCBzdXBlcnZpc2VGYWN0b3IgPSB0aGlzLnN1cGVydmlzZUZhY3RvciAvIDEwMDsgLy8gc2V0IGluIHJhbmdlIFswLCAxXVxuICAgIGxldCB1bmxhYmVsZWRDbGFzcyA9IHRoaXMudW5sYWJlbGVkQ2xhc3M7XG4gICAgbGV0IGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIGxldCBsYWJlbENvdW50cyA9IHRoaXMubGFiZWxDb3VudHM7XG4gICAgbGV0IHN1cGVydmlzZWQgPVxuICAgICAgc3VwZXJ2aXNlRmFjdG9yICE9IG51bGwgJiZcbiAgICAgIHN1cGVydmlzZUZhY3RvciA+IDAgJiZcbiAgICAgIGxhYmVscyAhPSBudWxsICYmXG4gICAgICBsYWJlbENvdW50cyAhPSBudWxsO1xuICAgIGxldCB1bmxhYmVsZWRDb3VudCA9XG4gICAgICBzdXBlcnZpc2VkICYmIHVubGFiZWxlZENsYXNzICE9IG51bGwgJiYgdW5sYWJlbGVkQ2xhc3MgIT09ICcnXG4gICAgICAgID8gbGFiZWxDb3VudHNbdW5sYWJlbGVkQ2xhc3NdXG4gICAgICAgIDogMDtcbiAgICAvLyBNYWtlIGRhdGEgZm9yIHRoZSBTUCB0cmVlLlxuICAgIGxldCBwb2ludHM6IG51bWJlcltdW10gPSBuZXcgQXJyYXkoTik7IC8vICh4LCB5KVtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGxldCBpVGltZXNEID0gaSAqIHRoaXMuZGltO1xuICAgICAgbGV0IHJvdyA9IG5ldyBBcnJheSh0aGlzLmRpbSk7XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHRoaXMuZGltOyArK2QpIHtcbiAgICAgICAgcm93W2RdID0gWVtpVGltZXNEICsgZF07XG4gICAgICB9XG4gICAgICBwb2ludHNbaV0gPSByb3c7XG4gICAgfVxuICAgIC8vIE1ha2UgYSB0cmVlLlxuICAgIGxldCB0cmVlID0gbmV3IFNQVHJlZShwb2ludHMpO1xuICAgIGxldCByb290ID0gdHJlZS5yb290IGFzIEF1Z21TUE5vZGU7XG4gICAgLy8gQW5ub3RhdGUgdGhlIHRyZWUuXG4gICAgbGV0IGFubm90YXRlVHJlZSA9IChcbiAgICAgIG5vZGU6IEF1Z21TUE5vZGVcbiAgICApOiB7XG4gICAgICBudW1DZWxsczogbnVtYmVyO1xuICAgICAgeUNlbGw6IG51bWJlcltdO1xuICAgIH0gPT4ge1xuICAgICAgbGV0IG51bUNlbGxzID0gMTtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IG5vZGUgYW5kIHRlbGwgdGhlIHBhcmVudC5cbiAgICAgICAgbm9kZS5udW1DZWxscyA9IG51bUNlbGxzO1xuICAgICAgICBub2RlLnlDZWxsID0gbm9kZS5wb2ludDtcbiAgICAgICAgcmV0dXJuIHtudW1DZWxscywgeUNlbGw6IG5vZGUueUNlbGx9O1xuICAgICAgfVxuICAgICAgLy8gbm9kZS5wb2ludCBpcyBhIDIgb3IgMy1kaW0gbnVtYmVyW10sIHNvIHNsaWNlKCkgbWFrZXMgYSBjb3B5LlxuICAgICAgbGV0IHlDZWxsID0gbm9kZS5wb2ludC5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGFubm90YXRlVHJlZShjaGlsZCBhcyBBdWdtU1BOb2RlKTtcbiAgICAgICAgbnVtQ2VsbHMgKz0gcmVzdWx0Lm51bUNlbGxzO1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHRoaXMuZGltOyArK2QpIHtcbiAgICAgICAgICB5Q2VsbFtkXSArPSByZXN1bHQueUNlbGxbZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbm9kZSBhbmQgdGVsbCB0aGUgcGFyZW50LlxuICAgICAgbm9kZS5udW1DZWxscyA9IG51bUNlbGxzO1xuICAgICAgbm9kZS55Q2VsbCA9IHlDZWxsLm1hcCgodikgPT4gdiAvIG51bUNlbGxzKTtcbiAgICAgIHJldHVybiB7bnVtQ2VsbHMsIHlDZWxsfTtcbiAgICB9O1xuICAgIC8vIEF1Z21lbnQgdGhlIHRyZWUgd2l0aCBtb3JlIGluZm8uXG4gICAgYW5ub3RhdGVUcmVlKHJvb3QpO1xuICAgIHRyZWUudmlzaXQoKG5vZGU6IEF1Z21TUE5vZGUsIGxvdzogbnVtYmVyW10sIGhpZ2g6IG51bWJlcltdKSA9PiB7XG4gICAgICBub2RlLnJDZWxsID0gaGlnaFswXSAtIGxvd1swXTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICAvLyBjb21wdXRlIGN1cnJlbnQgUSBkaXN0cmlidXRpb24sIHVubm9ybWFsaXplZCBmaXJzdFxuICAgIGxldCBncmFkOiBudW1iZXJbXVtdID0gW107XG4gICAgbGV0IFogPSAwO1xuICAgIGxldCBzdW1fcGlqID0gMDtcbiAgICBsZXQgZm9yY2VzOiBbbnVtYmVyW10sIG51bWJlcltdXVtdID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICBsZXQgcG9pbnRJID0gcG9pbnRzW2ldO1xuICAgICAgaWYgKHN1cGVydmlzZWQpIHtcbiAgICAgICAgdmFyIHNhbWVDb3VudCA9IGxhYmVsQ291bnRzW2xhYmVsc1tpXV07XG4gICAgICAgIHZhciBvdGhlckNvdW50ID0gTiAtIHNhbWVDb3VudCAtIHVubGFiZWxlZENvdW50O1xuICAgICAgfVxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpdmUgZm9yY2VzIGZvciB0aGUgaS10aCBub2RlLlxuICAgICAgbGV0IEZwb3MgPSB0aGlzLmRpbSA9PT0gMyA/IFswLCAwLCAwXSA6IFswLCAwXTtcbiAgICAgIGxldCBuZWlnaGJvcnMgPSB0aGlzLm5lYXJlc3RbaV07XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5laWdoYm9ycy5sZW5ndGg7ICsraykge1xuICAgICAgICBsZXQgaiA9IG5laWdoYm9yc1trXS5pbmRleDtcbiAgICAgICAgbGV0IHBpaiA9IFBbaSAqIE4gKyBqXTtcbiAgICAgICAgLy8gYXBwbHkgc2VtaS1zdXBlcnZpc2VkIHByaW9yIHByb2JhYmlsaXRpZXNcbiAgICAgICAgaWYgKHN1cGVydmlzZWQpIHtcbiAgICAgICAgICBpZiAobGFiZWxzW2ldID09PSB1bmxhYmVsZWRDbGFzcyB8fCBsYWJlbHNbal0gPT09IHVubGFiZWxlZENsYXNzKSB7XG4gICAgICAgICAgICBwaWogKj0gMSAvIE47XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbHNbaV0gIT09IGxhYmVsc1tqXSkge1xuICAgICAgICAgICAgcGlqICo9IE1hdGgubWF4KDEgLyBOIC0gc3VwZXJ2aXNlRmFjdG9yIC8gb3RoZXJDb3VudCwgMWUtNyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbHNbaV0gPT09IGxhYmVsc1tqXSkge1xuICAgICAgICAgICAgcGlqICo9IE1hdGgubWluKDEgLyBOICsgc3VwZXJ2aXNlRmFjdG9yIC8gc2FtZUNvdW50LCAxIC0gMWUtNyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1bV9waWogKz0gcGlqO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludEogPSBwb2ludHNbal07XG4gICAgICAgIGxldCBzcXVhcmVkRGlzdEl0b0ogPSB0aGlzLmRpc3QyKHBvaW50SSwgcG9pbnRKKTtcbiAgICAgICAgbGV0IHByZW11bHQgPSBwaWogLyAoMSArIHNxdWFyZWREaXN0SXRvSik7XG4gICAgICAgIHRoaXMuY29tcHV0ZUZvcmNlKEZwb3MsIHByZW11bHQsIHBvaW50SSwgcG9pbnRKKTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXB1dGUgdGhlIG5lZ2F0aXZlIGZvcmNlcyBmb3IgdGhlIGktdGggbm9kZS5cbiAgICAgIGxldCBGbmVnWiA9IHRoaXMuZGltID09PSAzID8gWzAsIDAsIDBdIDogWzAsIDBdO1xuICAgICAgdHJlZS52aXNpdCgobm9kZTogQXVnbVNQTm9kZSkgPT4ge1xuICAgICAgICBsZXQgc3F1YXJlZERpc3RUb0NlbGwgPSB0aGlzLmRpc3QyKHBvaW50SSwgbm9kZS55Q2VsbCk7XG4gICAgICAgIC8vIFNxdWFyZWQgZGlzdGFuY2UgZnJvbSBwb2ludCBpIHRvIGNlbGwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBub2RlLmNoaWxkcmVuID09IG51bGwgfHxcbiAgICAgICAgICAoc3F1YXJlZERpc3RUb0NlbGwgPiAwICYmXG4gICAgICAgICAgICBub2RlLnJDZWxsIC8gTWF0aC5zcXJ0KHNxdWFyZWREaXN0VG9DZWxsKSA8IFRIRVRBKVxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgcWlqWiA9IDEgLyAoMSArIHNxdWFyZWREaXN0VG9DZWxsKTtcbiAgICAgICAgICBsZXQgZFogPSBub2RlLm51bUNlbGxzICogcWlqWjtcbiAgICAgICAgICBaICs9IGRaO1xuICAgICAgICAgIGRaICo9IHFpalo7XG4gICAgICAgICAgdGhpcy5jb21wdXRlRm9yY2UoRm5lZ1osIGRaLCBwb2ludEksIG5vZGUueUNlbGwpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENlbGwgaXMgdG9vIGNsb3NlIHRvIGFwcHJveGltYXRlLlxuICAgICAgICBsZXQgc3F1YXJlZERpc3RUb1BvaW50ID0gdGhpcy5kaXN0Mihwb2ludEksIG5vZGUucG9pbnQpO1xuICAgICAgICBsZXQgcWlqWiA9IDEgLyAoMSArIHNxdWFyZWREaXN0VG9Qb2ludCk7XG4gICAgICAgIFogKz0gcWlqWjtcbiAgICAgICAgcWlqWiAqPSBxaWpaO1xuICAgICAgICB0aGlzLmNvbXB1dGVGb3JjZShGbmVnWiwgcWlqWiwgcG9pbnRJLCBub2RlLnBvaW50KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBmb3JjZXNbaV0gPSBbRnBvcywgRm5lZ1pdO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdGhlIG5lZ2F0aXZlIGZvcmNlcyBhbmQgY29tcHV0ZSB0aGUgZ3JhZGllbnQuXG4gICAgbGV0IEEgPSA0ICogYWxwaGE7XG4gICAgaWYgKHN1cGVydmlzZWQpIHtcbiAgICAgIEEgLz0gc3VtX3BpajtcbiAgICB9XG4gICAgY29uc3QgQiA9IDQgLyBaO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICBsZXQgW0ZQb3MsIEZOZWdaXSA9IGZvcmNlc1tpXTtcbiAgICAgIGxldCBnc3VtID0gbmV3IEFycmF5KHRoaXMuZGltKTtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICBnc3VtW2RdID0gQSAqIEZQb3NbZF0gLSBCICogRk5lZ1pbZF07XG4gICAgICB9XG4gICAgICBncmFkLnB1c2goZ3N1bSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG59XG4iXX0=