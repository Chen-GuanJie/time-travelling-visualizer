/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
/**
 * This is a fork of the Karpathy's TSNE.js (original license below).
 * This fork implements Barnes-Hut approximation and runs in O(NlogN)
 * time, as opposed to the Karpathy's O(N^2) version.
 *
 * Please refer to third_party/bh_tsne.LICENSE for the original license.
 *
 * @author smilkov@google.com (Daniel Smilkov)
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("org_tensorflow_tensorboard/tensorboard/projector/bh_tsne", ["require", "exports", "org_tensorflow_tensorboard/tensorboard/projector/sptree"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const sptree_1 = require("org_tensorflow_tensorboard/tensorboard/projector/sptree");
    /**
     * Barnes-hut approximation level. Higher means more approximation and faster
     * results. Recommended value mentioned in the paper is 0.8.
     */
    const THETA = 0.8;
    const MIN_POSSIBLE_PROB = 1e-9;
    // Variables used for memorizing the second random number since running
    // gaussRandom() generates two random numbers at the cost of 1 atomic
    // computation. This optimization results in 2X speed-up of the generator.
    let return_v = false;
    let v_val = 0;
    /** Returns the square euclidean distance between two vectors. */
    function dist2(a, b) {
        if (a.length !== b.length) {
            throw new Error('Vectors a and b must be of same length');
        }
        let result = 0;
        for (let i = 0; i < a.length; ++i) {
            let diff = a[i] - b[i];
            result += diff * diff;
        }
        return result;
    }
    exports.dist2 = dist2;
    /** Returns the square euclidean distance between two 2D points. */
    function dist2_2D(a, b) {
        let dX = a[0] - b[0];
        let dY = a[1] - b[1];
        return dX * dX + dY * dY;
    }
    exports.dist2_2D = dist2_2D;
    /** Returns the square euclidean distance between two 3D points. */
    function dist2_3D(a, b) {
        let dX = a[0] - b[0];
        let dY = a[1] - b[1];
        let dZ = a[2] - b[2];
        return dX * dX + dY * dY + dZ * dZ;
    }
    exports.dist2_3D = dist2_3D;
    function gaussRandom(rng) {
        if (return_v) {
            return_v = false;
            return v_val;
        }
        let u = 2 * rng() - 1;
        let v = 2 * rng() - 1;
        let r = u * u + v * v;
        if (r === 0 || r > 1) {
            return gaussRandom(rng);
        }
        let c = Math.sqrt((-2 * Math.log(r)) / r);
        v_val = v * c; // cache this for next function call for efficiency
        return_v = true;
        return u * c;
    }
    // return random normal number
    function randn(rng, mu, std) {
        return mu + gaussRandom(rng) * std;
    }
    // utilitity that creates contiguous vector of zeros of size n
    function zeros(n) {
        return new Float64Array(n);
    }
    // utility that returns a matrix filled with random numbers
    // generated by the provided generator.
    function randnMatrix(n, d, rng) {
        let nd = n * d;
        let x = zeros(nd);
        for (let i = 0; i < nd; ++i) {
            x[i] = randn(rng, 0, 0.0001);
        }
        return x;
    }
    // utility that returns a matrix filled with the provided value.
    function arrayofs(n, d, val) {
        let x = [];
        for (let i = 0; i < n; ++i) {
            x.push(d === 3 ? [val, val, val] : [val, val]);
        }
        return x;
    }
    // compute (p_{i|j} + p_{j|i})/(2n)
    function nearest2P(nearest, perplexity, tol) {
        let N = nearest.length;
        let Htarget = Math.log(perplexity); // target entropy of distribution
        let P = zeros(N * N); // temporary probability matrix
        let K = nearest[0].length;
        let pRow = new Array(K); // pij[].
        for (let i = 0; i < N; ++i) {
            let neighbors = nearest[i];
            let betaMin = -Infinity;
            let betaMax = Infinity;
            let beta = 1; // initial value of precision
            let maxTries = 50;
            // perform binary search to find a suitable precision beta
            // so that the entropy of the distribution is appropriate
            let numTries = 0;
            while (true) {
                // compute entropy and kernel row with beta precision
                let psum = 0;
                for (let k = 0; k < neighbors.length; ++k) {
                    let neighbor = neighbors[k];
                    let pij = i === neighbor.index ? 0 : Math.exp(-neighbor.dist * beta);
                    pij = Math.max(pij, MIN_POSSIBLE_PROB);
                    pRow[k] = pij;
                    psum += pij;
                }
                // normalize p and compute entropy
                let Hhere = 0;
                for (let k = 0; k < pRow.length; ++k) {
                    pRow[k] /= psum;
                    let pij = pRow[k];
                    if (pij > 1e-7) {
                        Hhere -= pij * Math.log(pij);
                    }
                }
                // adjust beta based on result
                if (Hhere > Htarget) {
                    // entropy was too high (distribution too diffuse)
                    // so we need to increase the precision for more peaky distribution
                    betaMin = beta; // move up the bounds
                    if (betaMax === Infinity) {
                        beta = beta * 2;
                    }
                    else {
                        beta = (beta + betaMax) / 2;
                    }
                }
                else {
                    // converse case. make distrubtion less peaky
                    betaMax = beta;
                    if (betaMin === -Infinity) {
                        beta = beta / 2;
                    }
                    else {
                        beta = (beta + betaMin) / 2;
                    }
                }
                numTries++;
                // stopping conditions: too many tries or got a good precision
                if (numTries >= maxTries || Math.abs(Hhere - Htarget) < tol) {
                    break;
                }
            }
            // copy over the final prow to P at row i
            for (let k = 0; k < pRow.length; ++k) {
                let pij = pRow[k];
                let j = neighbors[k].index;
                P[i * N + j] = pij;
            }
        } // end loop over examples i
        // symmetrize P and normalize it to sum to 1 over all ij
        let N2 = N * 2;
        for (let i = 0; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let i_j = i * N + j;
                let j_i = j * N + i;
                let value = (P[i_j] + P[j_i]) / N2;
                P[i_j] = value;
                P[j_i] = value;
            }
        }
        return P;
    }
    // helper function
    function sign(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function computeForce_2d(force, mult, pointA, pointB) {
        force[0] += mult * (pointA[0] - pointB[0]);
        force[1] += mult * (pointA[1] - pointB[1]);
    }
    function computeForce_3d(force, mult, pointA, pointB) {
        force[0] += mult * (pointA[0] - pointB[0]);
        force[1] += mult * (pointA[1] - pointB[1]);
        force[2] += mult * (pointA[2] - pointB[2]);
    }
    class TSNE {
        constructor(opt) {
            this.iter = 0;
            opt = opt || { dim: 2 };
            this.perplexity = opt.perplexity || 30;
            this.epsilon = opt.epsilon || 10;
            this.rng = opt.rng || Math.random;
            this.dim = opt.dim;
            if (opt.dim === 2) {
                this.dist2 = dist2_2D;
                this.computeForce = computeForce_2d;
            }
            else if (opt.dim === 3) {
                this.dist2 = dist2_3D;
                this.computeForce = computeForce_3d;
            }
            else {
                throw new Error('Only 2D and 3D is supported');
            }
        }
        // this function takes a fattened distance matrix and creates
        // matrix P from them.
        // D is assumed to be provided as an array of size N^2.
        initDataDist(nearest) {
            let N = nearest.length;
            this.nearest = nearest;
            this.P = nearest2P(nearest, this.perplexity, 0.0001);
            this.N = N;
            this.initSolution(); // refresh this
        }
        // (re)initializes the solution to random
        initSolution() {
            // generate random solution to t-SNE
            this.Y = randnMatrix(this.N, this.dim, this.rng); // the solution
            this.gains = arrayofs(this.N, this.dim, 1); // step gains
            // to accelerate progress in unchanging directions
            this.ystep = arrayofs(this.N, this.dim, 0); // momentum accumulator
            this.iter = 0;
        }
        getDim() {
            return this.dim;
        }
        // return pointer to current solution
        getSolution() {
            return this.Y;
        }
        // For each point, randomly offset point within a 5% hypersphere centered
        // around it, whilst remaining in the assumed t-SNE plot hypersphere
        perturb() {
            let N = this.N;
            let maxArea = 0;
            let ymean = this.dim === 3 ? [0, 0, 0] : [0, 0];
            // Determine radius of t-SNE hypersphere, assumed zero mean and normalized
            // dimensions. Here area is proportional to pi*radius^2, to skip root calc.
            for (let i = 0; i < N; ++i) {
                let area = 0;
                for (let d = 0; d < this.dim; ++d) {
                    area += Math.pow(this.Y[i * this.dim + d], 2);
                }
                if (area > maxArea) {
                    maxArea = area;
                }
            }
            let maxRadius = Math.pow(maxArea, 0.5);
            for (let i = 0; i < N; ++i) {
                let diff = new Array(this.dim);
                // Find a perturbation of point that fits inside t-SNE hypersphere
                while (true) {
                    let area = 0;
                    for (let d = 0; d < this.dim; ++d) {
                        diff[d] = 0.1 * maxRadius * (Math.random() - 0.5);
                        area += Math.pow(this.Y[i * this.dim + d] + diff[d], 2);
                    }
                    if (area < maxArea) {
                        break;
                    }
                }
                // Apply offset to point
                for (let d = 0; d < this.dim; ++d) {
                    this.Y[i * this.dim + d] += diff[d];
                    ymean[d] += this.Y[i * this.dim + d];
                }
            }
            // reproject Y to be zero mean
            for (let i = 0; i < N; ++i) {
                for (let d = 0; d < this.dim; ++d) {
                    this.Y[i * this.dim + d] -= ymean[d] / N;
                }
            }
        }
        // perform a single step of optimization to improve the embedding
        step() {
            this.iter += 1;
            let N = this.N;
            let grad = this.costGrad(this.Y); // evaluate gradient
            // perform gradient step
            let ymean = this.dim === 3 ? [0, 0, 0] : [0, 0];
            for (let i = 0; i < N; ++i) {
                for (let d = 0; d < this.dim; ++d) {
                    let gid = grad[i][d];
                    let sid = this.ystep[i][d];
                    let gainid = this.gains[i][d];
                    // compute gain update
                    let newgain = sign(gid) === sign(sid) ? gainid * 0.8 : gainid + 0.2;
                    if (newgain < 0.01) {
                        newgain = 0.01; // clamp
                    }
                    this.gains[i][d] = newgain; // store for next turn
                    // compute momentum step direction
                    let momval = this.iter < 250 ? 0.5 : 0.8;
                    let newsid = momval * sid - this.epsilon * newgain * grad[i][d];
                    this.ystep[i][d] = newsid; // remember the step we took
                    // step!
                    let i_d = i * this.dim + d;
                    this.Y[i_d] += newsid;
                    ymean[d] += this.Y[i_d]; // accumulate mean so that we
                    // can center later
                }
            }
            // reproject Y to be zero mean
            for (let i = 0; i < N; ++i) {
                for (let d = 0; d < this.dim; ++d) {
                    this.Y[i * this.dim + d] -= ymean[d] / N;
                }
            }
        }
        setSupervision(superviseLabels, superviseInput) {
            if (superviseLabels != null) {
                this.labels = superviseLabels;
                this.labelCounts = {};
                let uniqueEntries = Array.from(new Set(superviseLabels));
                uniqueEntries.forEach((l) => (this.labelCounts[l] = 0));
                superviseLabels.forEach((l) => (this.labelCounts[l] += 1));
            }
            if (superviseInput != null) {
                this.unlabeledClass = superviseInput;
            }
        }
        setSuperviseFactor(superviseFactor) {
            if (superviseFactor != null) {
                this.superviseFactor = superviseFactor;
            }
        }
        // return cost and gradient, given an arrangement
        costGrad(Y) {
            let N = this.N;
            let P = this.P;
            // Trick that helps with local optima.
            let alpha = this.iter < 100 ? 4 : 1;
            let superviseFactor = this.superviseFactor / 100; // set in range [0, 1]
            let unlabeledClass = this.unlabeledClass;
            let labels = this.labels;
            let labelCounts = this.labelCounts;
            let supervised = superviseFactor != null &&
                superviseFactor > 0 &&
                labels != null &&
                labelCounts != null;
            let unlabeledCount = supervised && unlabeledClass != null && unlabeledClass !== ''
                ? labelCounts[unlabeledClass]
                : 0;
            // Make data for the SP tree.
            let points = new Array(N); // (x, y)[]
            for (let i = 0; i < N; ++i) {
                let iTimesD = i * this.dim;
                let row = new Array(this.dim);
                for (let d = 0; d < this.dim; ++d) {
                    row[d] = Y[iTimesD + d];
                }
                points[i] = row;
            }
            // Make a tree.
            let tree = new sptree_1.SPTree(points);
            let root = tree.root;
            // Annotate the tree.
            let annotateTree = (node) => {
                let numCells = 1;
                if (node.children == null) {
                    // Update the current node and tell the parent.
                    node.numCells = numCells;
                    node.yCell = node.point;
                    return { numCells, yCell: node.yCell };
                }
                // node.point is a 2 or 3-dim number[], so slice() makes a copy.
                let yCell = node.point.slice();
                for (let i = 0; i < node.children.length; ++i) {
                    let child = node.children[i];
                    if (child == null) {
                        continue;
                    }
                    let result = annotateTree(child);
                    numCells += result.numCells;
                    for (let d = 0; d < this.dim; ++d) {
                        yCell[d] += result.yCell[d];
                    }
                }
                // Update the node and tell the parent.
                node.numCells = numCells;
                node.yCell = yCell.map((v) => v / numCells);
                return { numCells, yCell };
            };
            // Augment the tree with more info.
            annotateTree(root);
            tree.visit((node, low, high) => {
                node.rCell = high[0] - low[0];
                return false;
            });
            // compute current Q distribution, unnormalized first
            let grad = [];
            let Z = 0;
            let sum_pij = 0;
            let forces = new Array(N);
            for (let i = 0; i < N; ++i) {
                let pointI = points[i];
                if (supervised) {
                    var sameCount = labelCounts[labels[i]];
                    var otherCount = N - sameCount - unlabeledCount;
                }
                // Compute the positive forces for the i-th node.
                let Fpos = this.dim === 3 ? [0, 0, 0] : [0, 0];
                let neighbors = this.nearest[i];
                for (let k = 0; k < neighbors.length; ++k) {
                    let j = neighbors[k].index;
                    let pij = P[i * N + j];
                    // apply semi-supervised prior probabilities
                    if (supervised) {
                        if (labels[i] === unlabeledClass || labels[j] === unlabeledClass) {
                            pij *= 1 / N;
                        }
                        else if (labels[i] !== labels[j]) {
                            pij *= Math.max(1 / N - superviseFactor / otherCount, 1e-7);
                        }
                        else if (labels[i] === labels[j]) {
                            pij *= Math.min(1 / N + superviseFactor / sameCount, 1 - 1e-7);
                        }
                        sum_pij += pij;
                    }
                    let pointJ = points[j];
                    let squaredDistItoJ = this.dist2(pointI, pointJ);
                    let premult = pij / (1 + squaredDistItoJ);
                    this.computeForce(Fpos, premult, pointI, pointJ);
                }
                // Compute the negative forces for the i-th node.
                let FnegZ = this.dim === 3 ? [0, 0, 0] : [0, 0];
                tree.visit((node) => {
                    let squaredDistToCell = this.dist2(pointI, node.yCell);
                    // Squared distance from point i to cell.
                    if (node.children == null ||
                        (squaredDistToCell > 0 &&
                            node.rCell / Math.sqrt(squaredDistToCell) < THETA)) {
                        let qijZ = 1 / (1 + squaredDistToCell);
                        let dZ = node.numCells * qijZ;
                        Z += dZ;
                        dZ *= qijZ;
                        this.computeForce(FnegZ, dZ, pointI, node.yCell);
                        return true;
                    }
                    // Cell is too close to approximate.
                    let squaredDistToPoint = this.dist2(pointI, node.point);
                    let qijZ = 1 / (1 + squaredDistToPoint);
                    Z += qijZ;
                    qijZ *= qijZ;
                    this.computeForce(FnegZ, qijZ, pointI, node.point);
                    return false;
                }, true);
                forces[i] = [Fpos, FnegZ];
            }
            // Normalize the negative forces and compute the gradient.
            let A = 4 * alpha;
            if (supervised) {
                A /= sum_pij;
            }
            const B = 4 / Z;
            for (let i = 0; i < N; ++i) {
                let [FPos, FNegZ] = forces[i];
                let gsum = new Array(this.dim);
                for (let d = 0; d < this.dim; ++d) {
                    gsum[d] = A * FPos[d] - B * FNegZ[d];
                }
                grad.push(gsum);
            }
            return grad;
        }
    }
    exports.TSNE = TSNE;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmhfdHNuZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RlbnNvcmJvYXJkL3Byb2plY3Rvci9iaF90c25lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O2dGQWFnRjtBQUNoRjs7Ozs7Ozs7R0FRRzs7Ozs7Ozs7Ozs7O0lBRUgsb0ZBQXdDO0lBT3hDOzs7T0FHRztJQUNILE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQztJQUNsQixNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQztJQUMvQix1RUFBdUU7SUFDdkUscUVBQXFFO0lBQ3JFLDBFQUEwRTtJQUMxRSxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7SUFDckIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsaUVBQWlFO0lBQ2pFLFNBQWdCLEtBQUssQ0FBQyxDQUFXLEVBQUUsQ0FBVztRQUM1QyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRTtZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7U0FDM0Q7UUFDRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDZixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtZQUNqQyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ3ZCO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQVZELHNCQVVDO0lBQ0QsbUVBQW1FO0lBQ25FLFNBQWdCLFFBQVEsQ0FBQyxDQUFXLEVBQUUsQ0FBVztRQUMvQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMs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LEVBQUUsRUFBRSxDQUFDLEVBQUU7b0JBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ3RDO2dCQUNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakI7WUFDRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7S0FDRjtJQS9URCxvQkErVEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgMjAxNiBUaGUgVGVuc29yRmxvdyBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKipcbiAqIFRoaXMgaXMgYSBmb3JrIG9mIHRoZSBLYXJwYXRoeSdzIFRTTkUuanMgKG9yaWdpbmFsIGxpY2Vuc2UgYmVsb3cpLlxuICogVGhpcyBmb3JrIGltcGxlbWVudHMgQmFybmVzLUh1dCBhcHByb3hpbWF0aW9uIGFuZCBydW5zIGluIE8oTmxvZ04pXG4gKiB0aW1lLCBhcyBvcHBvc2VkIHRvIHRoZSBLYXJwYXRoeSdzIE8oTl4yKSB2ZXJzaW9uLlxuICpcbiAqIFBsZWFzZSByZWZlciB0byB0aGlyZF9wYXJ0eS9iaF90c25lLkxJQ0VOU0UgZm9yIHRoZSBvcmlnaW5hbCBsaWNlbnNlLlxuICpcbiAqIEBhdXRob3Igc21pbGtvdkBnb29nbGUuY29tIChEYW5pZWwgU21pbGtvdilcbiAqL1xuXG5pbXBvcnQge1NQTm9kZSwgU1BUcmVlfSBmcm9tICcuL3NwdHJlZSc7XG5cbnR5cGUgQXVnbVNQTm9kZSA9IFNQTm9kZSAmIHtcbiAgbnVtQ2VsbHM6IG51bWJlcjtcbiAgeUNlbGw6IG51bWJlcltdO1xuICByQ2VsbDogbnVtYmVyO1xufTtcbi8qKlxuICogQmFybmVzLWh1dCBhcHByb3hpbWF0aW9uIGxldmVsLiBIaWdoZXIgbWVhbnMgbW9yZSBhcHByb3hpbWF0aW9uIGFuZCBmYXN0ZXJcbiAqIHJlc3VsdHMuIFJlY29tbWVuZGVkIHZhbHVlIG1lbnRpb25lZCBpbiB0aGUgcGFwZXIgaXMgMC44LlxuICovXG5jb25zdCBUSEVUQSA9IDAuODtcbmNvbnN0IE1JTl9QT1NTSUJMRV9QUk9CID0gMWUtOTtcbi8vIFZhcmlhYmxlcyB1c2VkIGZvciBtZW1vcml6aW5nIHRoZSBzZWNvbmQgcmFuZG9tIG51bWJlciBzaW5jZSBydW5uaW5nXG4vLyBnYXVzc1JhbmRvbSgpIGdlbmVyYXRlcyB0d28gcmFuZG9tIG51bWJlcnMgYXQgdGhlIGNvc3Qgb2YgMSBhdG9taWNcbi8vIGNvbXB1dGF0aW9uLiBUaGlzIG9wdGltaXphdGlvbiByZXN1bHRzIGluIDJYIHNwZWVkLXVwIG9mIHRoZSBnZW5lcmF0b3IuXG5sZXQgcmV0dXJuX3YgPSBmYWxzZTtcbmxldCB2X3ZhbCA9IDA7XG4vKiogUmV0dXJucyB0aGUgc3F1YXJlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3QyKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlY3RvcnMgYSBhbmQgYiBtdXN0IGJlIG9mIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBkaWZmID0gYVtpXSAtIGJbaV07XG4gICAgcmVzdWx0ICs9IGRpZmYgKiBkaWZmO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKiogUmV0dXJucyB0aGUgc3F1YXJlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byAyRCBwb2ludHMuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdDJfMkQoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IGRYID0gYVswXSAtIGJbMF07XG4gIGxldCBkWSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gZFggKiBkWCArIGRZICogZFk7XG59XG4vKiogUmV0dXJucyB0aGUgc3F1YXJlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byAzRCBwb2ludHMuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdDJfM0QoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IGRYID0gYVswXSAtIGJbMF07XG4gIGxldCBkWSA9IGFbMV0gLSBiWzFdO1xuICBsZXQgZFogPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGRYICogZFggKyBkWSAqIGRZICsgZFogKiBkWjtcbn1cbmZ1bmN0aW9uIGdhdXNzUmFuZG9tKHJuZzogKCkgPT4gbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHJldHVybl92KSB7XG4gICAgcmV0dXJuX3YgPSBmYWxzZTtcbiAgICByZXR1cm4gdl92YWw7XG4gIH1cbiAgbGV0IHUgPSAyICogcm5nKCkgLSAxO1xuICBsZXQgdiA9IDIgKiBybmcoKSAtIDE7XG4gIGxldCByID0gdSAqIHUgKyB2ICogdjtcbiAgaWYgKHIgPT09IDAgfHwgciA+IDEpIHtcbiAgICByZXR1cm4gZ2F1c3NSYW5kb20ocm5nKTtcbiAgfVxuICBsZXQgYyA9IE1hdGguc3FydCgoLTIgKiBNYXRoLmxvZyhyKSkgLyByKTtcbiAgdl92YWwgPSB2ICogYzsgLy8gY2FjaGUgdGhpcyBmb3IgbmV4dCBmdW5jdGlvbiBjYWxsIGZvciBlZmZpY2llbmN5XG4gIHJldHVybl92ID0gdHJ1ZTtcbiAgcmV0dXJuIHUgKiBjO1xufVxuLy8gcmV0dXJuIHJhbmRvbSBub3JtYWwgbnVtYmVyXG5mdW5jdGlvbiByYW5kbihybmc6ICgpID0+IG51bWJlciwgbXU6IG51bWJlciwgc3RkOiBudW1iZXIpIHtcbiAgcmV0dXJuIG11ICsgZ2F1c3NSYW5kb20ocm5nKSAqIHN0ZDtcbn1cbi8vIHV0aWxpdGl0eSB0aGF0IGNyZWF0ZXMgY29udGlndW91cyB2ZWN0b3Igb2YgemVyb3Mgb2Ygc2l6ZSBuXG5mdW5jdGlvbiB6ZXJvcyhuOiBudW1iZXIpOiBGbG9hdDY0QXJyYXkge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShuKTtcbn1cbi8vIHV0aWxpdHkgdGhhdCByZXR1cm5zIGEgbWF0cml4IGZpbGxlZCB3aXRoIHJhbmRvbSBudW1iZXJzXG4vLyBnZW5lcmF0ZWQgYnkgdGhlIHByb3ZpZGVkIGdlbmVyYXRvci5cbmZ1bmN0aW9uIHJhbmRuTWF0cml4KG46IG51bWJlciwgZDogbnVtYmVyLCBybmc6ICgpID0+IG51bWJlcikge1xuICBsZXQgbmQgPSBuICogZDtcbiAgbGV0IHggPSB6ZXJvcyhuZCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmQ7ICsraSkge1xuICAgIHhbaV0gPSByYW5kbihybmcsIDAsIDAuMDAwMSk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG4vLyB1dGlsaXR5IHRoYXQgcmV0dXJucyBhIG1hdHJpeCBmaWxsZWQgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuXG5mdW5jdGlvbiBhcnJheW9mcyhuOiBudW1iZXIsIGQ6IG51bWJlciwgdmFsOiBudW1iZXIpIHtcbiAgbGV0IHg6IG51bWJlcltdW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB4LnB1c2goZCA9PT0gMyA/IFt2YWwsIHZhbCwgdmFsXSA6IFt2YWwsIHZhbF0pO1xuICB9XG4gIHJldHVybiB4O1xufVxuLy8gY29tcHV0ZSAocF97aXxqfSArIHBfe2p8aX0pLygybilcbmZ1bmN0aW9uIG5lYXJlc3QyUChcbiAgbmVhcmVzdDoge1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgZGlzdDogbnVtYmVyO1xuICB9W11bXSxcbiAgcGVycGxleGl0eTogbnVtYmVyLFxuICB0b2w6IG51bWJlclxuKSB7XG4gIGxldCBOID0gbmVhcmVzdC5sZW5ndGg7XG4gIGxldCBIdGFyZ2V0ID0gTWF0aC5sb2cocGVycGxleGl0eSk7IC8vIHRhcmdldCBlbnRyb3B5IG9mIGRpc3RyaWJ1dGlvblxuICBsZXQgUCA9IHplcm9zKE4gKiBOKTsgLy8gdGVtcG9yYXJ5IHByb2JhYmlsaXR5IG1hdHJpeFxuICBsZXQgSyA9IG5lYXJlc3RbMF0ubGVuZ3RoO1xuICBsZXQgcFJvdzogbnVtYmVyW10gPSBuZXcgQXJyYXkoSyk7IC8vIHBpaltdLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGxldCBuZWlnaGJvcnMgPSBuZWFyZXN0W2ldO1xuICAgIGxldCBiZXRhTWluID0gLUluZmluaXR5O1xuICAgIGxldCBiZXRhTWF4ID0gSW5maW5pdHk7XG4gICAgbGV0IGJldGEgPSAxOyAvLyBpbml0aWFsIHZhbHVlIG9mIHByZWNpc2lvblxuICAgIGxldCBtYXhUcmllcyA9IDUwO1xuICAgIC8vIHBlcmZvcm0gYmluYXJ5IHNlYXJjaCB0byBmaW5kIGEgc3VpdGFibGUgcHJlY2lzaW9uIGJldGFcbiAgICAvLyBzbyB0aGF0IHRoZSBlbnRyb3B5IG9mIHRoZSBkaXN0cmlidXRpb24gaXMgYXBwcm9wcmlhdGVcbiAgICBsZXQgbnVtVHJpZXMgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBjb21wdXRlIGVudHJvcHkgYW5kIGtlcm5lbCByb3cgd2l0aCBiZXRhIHByZWNpc2lvblxuICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuZWlnaGJvcnMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgbGV0IG5laWdoYm9yID0gbmVpZ2hib3JzW2tdO1xuICAgICAgICBsZXQgcGlqID0gaSA9PT0gbmVpZ2hib3IuaW5kZXggPyAwIDogTWF0aC5leHAoLW5laWdoYm9yLmRpc3QgKiBiZXRhKTtcbiAgICAgICAgcGlqID0gTWF0aC5tYXgocGlqLCBNSU5fUE9TU0lCTEVfUFJPQik7XG4gICAgICAgIHBSb3dba10gPSBwaWo7XG4gICAgICAgIHBzdW0gKz0gcGlqO1xuICAgICAgfVxuICAgICAgLy8gbm9ybWFsaXplIHAgYW5kIGNvbXB1dGUgZW50cm9weVxuICAgICAgbGV0IEhoZXJlID0gMDtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcFJvdy5sZW5ndGg7ICsraykge1xuICAgICAgICBwUm93W2tdIC89IHBzdW07XG4gICAgICAgIGxldCBwaWogPSBwUm93W2tdO1xuICAgICAgICBpZiAocGlqID4gMWUtNykge1xuICAgICAgICAgIEhoZXJlIC09IHBpaiAqIE1hdGgubG9nKHBpaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFkanVzdCBiZXRhIGJhc2VkIG9uIHJlc3VsdFxuICAgICAgaWYgKEhoZXJlID4gSHRhcmdldCkge1xuICAgICAgICAvLyBlbnRyb3B5IHdhcyB0b28gaGlnaCAoZGlzdHJpYnV0aW9uIHRvbyBkaWZmdXNlKVxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGluY3JlYXNlIHRoZSBwcmVjaXNpb24gZm9yIG1vcmUgcGVha3kgZGlzdHJpYnV0aW9uXG4gICAgICAgIGJldGFNaW4gPSBiZXRhOyAvLyBtb3ZlIHVwIHRoZSBib3VuZHNcbiAgICAgICAgaWYgKGJldGFNYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgYmV0YSA9IGJldGEgKiAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJldGEgPSAoYmV0YSArIGJldGFNYXgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVyc2UgY2FzZS4gbWFrZSBkaXN0cnVidGlvbiBsZXNzIHBlYWt5XG4gICAgICAgIGJldGFNYXggPSBiZXRhO1xuICAgICAgICBpZiAoYmV0YU1pbiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgYmV0YSA9IGJldGEgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJldGEgPSAoYmV0YSArIGJldGFNaW4pIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbnVtVHJpZXMrKztcbiAgICAgIC8vIHN0b3BwaW5nIGNvbmRpdGlvbnM6IHRvbyBtYW55IHRyaWVzIG9yIGdvdCBhIGdvb2QgcHJlY2lzaW9uXG4gICAgICBpZiAobnVtVHJpZXMgPj0gbWF4VHJpZXMgfHwgTWF0aC5hYnMoSGhlcmUgLSBIdGFyZ2V0KSA8IHRvbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSBvdmVyIHRoZSBmaW5hbCBwcm93IHRvIFAgYXQgcm93IGlcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IHBSb3cubGVuZ3RoOyArK2spIHtcbiAgICAgIGxldCBwaWogPSBwUm93W2tdO1xuICAgICAgbGV0IGogPSBuZWlnaGJvcnNba10uaW5kZXg7XG4gICAgICBQW2kgKiBOICsgal0gPSBwaWo7XG4gICAgfVxuICB9IC8vIGVuZCBsb29wIG92ZXIgZXhhbXBsZXMgaVxuICAvLyBzeW1tZXRyaXplIFAgYW5kIG5vcm1hbGl6ZSBpdCB0byBzdW0gdG8gMSBvdmVyIGFsbCBpalxuICBsZXQgTjIgPSBOICogMjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgIGxldCBpX2ogPSBpICogTiArIGo7XG4gICAgICBsZXQgal9pID0gaiAqIE4gKyBpO1xuICAgICAgbGV0IHZhbHVlID0gKFBbaV9qXSArIFBbal9pXSkgLyBOMjtcbiAgICAgIFBbaV9qXSA9IHZhbHVlO1xuICAgICAgUFtqX2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBQO1xufVxuLy8gaGVscGVyIGZ1bmN0aW9uXG5mdW5jdGlvbiBzaWduKHg6IG51bWJlcikge1xuICByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7XG59XG5mdW5jdGlvbiBjb21wdXRlRm9yY2VfMmQoXG4gIGZvcmNlOiBudW1iZXJbXSxcbiAgbXVsdDogbnVtYmVyLFxuICBwb2ludEE6IG51bWJlcltdLFxuICBwb2ludEI6IG51bWJlcltdXG4pIHtcbiAgZm9yY2VbMF0gKz0gbXVsdCAqIChwb2ludEFbMF0gLSBwb2ludEJbMF0pO1xuICBmb3JjZVsxXSArPSBtdWx0ICogKHBvaW50QVsxXSAtIHBvaW50QlsxXSk7XG59XG5mdW5jdGlvbiBjb21wdXRlRm9yY2VfM2QoXG4gIGZvcmNlOiBudW1iZXJbXSxcbiAgbXVsdDogbnVtYmVyLFxuICBwb2ludEE6IG51bWJlcltdLFxuICBwb2ludEI6IG51bWJlcltdXG4pIHtcbiAgZm9yY2VbMF0gKz0gbXVsdCAqIChwb2ludEFbMF0gLSBwb2ludEJbMF0pO1xuICBmb3JjZVsxXSArPSBtdWx0ICogKHBvaW50QVsxXSAtIHBvaW50QlsxXSk7XG4gIGZvcmNlWzJdICs9IG11bHQgKiAocG9pbnRBWzJdIC0gcG9pbnRCWzJdKTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVFNORU9wdGlvbnMge1xuICAvKiogSG93IG1hbnkgZGltZW5zaW9ucy4gKi9cbiAgZGltOiBudW1iZXI7XG4gIC8qKiBSb3VnaGx5IGhvdyBtYW55IG5laWdoYm9ycyBlYWNoIHBvaW50IGluZmx1ZW5jZXMuICovXG4gIHBlcnBsZXhpdHk/OiBudW1iZXI7XG4gIC8qKiBMZWFybmluZyByYXRlLiAqL1xuICBlcHNpbG9uPzogbnVtYmVyO1xuICAvKiogQSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gKi9cbiAgcm5nPzogKCkgPT4gbnVtYmVyO1xufVxuZXhwb3J0IGNsYXNzIFRTTkUge1xuICBwcml2YXRlIHBlcnBsZXhpdHk6IG51bWJlcjtcbiAgcHJpdmF0ZSBlcHNpbG9uOiBudW1iZXI7XG4gIHByaXZhdGUgc3VwZXJ2aXNlRmFjdG9yOiBudW1iZXI7XG4gIHByaXZhdGUgdW5sYWJlbGVkQ2xhc3M6IHN0cmluZztcbiAgcHJpdmF0ZSBsYWJlbHM6IHN0cmluZ1tdO1xuICBwcml2YXRlIGxhYmVsQ291bnRzOiB7XG4gICAgW2tleTogc3RyaW5nXTogbnVtYmVyO1xuICB9O1xuICAvKiogUmFuZG9tIGdlbmVyYXRvciAqL1xuICBwcml2YXRlIHJuZzogKCkgPT4gbnVtYmVyO1xuICBwcml2YXRlIGl0ZXIgPSAwO1xuICBwcml2YXRlIFk6IEZsb2F0NjRBcnJheTtcbiAgcHJpdmF0ZSBOOiBudW1iZXI7XG4gIHByaXZhdGUgUDogRmxvYXQ2NEFycmF5O1xuICBwcml2YXRlIGdhaW5zOiBudW1iZXJbXVtdO1xuICBwcml2YXRlIHlzdGVwOiBudW1iZXJbXVtdO1xuICBwcml2YXRlIG5lYXJlc3Q6IHtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIGRpc3Q6IG51bWJlcjtcbiAgfVtdW107XG4gIHByaXZhdGUgZGltOiBudW1iZXI7XG4gIHByaXZhdGUgZGlzdDI6IChhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pID0+IG51bWJlcjtcbiAgcHJpdmF0ZSBjb21wdXRlRm9yY2U6IChcbiAgICBmb3JjZTogbnVtYmVyW10sXG4gICAgbXVsdDogbnVtYmVyLFxuICAgIHBvaW50QTogbnVtYmVyW10sXG4gICAgcG9pbnRCOiBudW1iZXJbXVxuICApID0+IHZvaWQ7XG4gIGNvbnN0cnVjdG9yKG9wdDogVFNORU9wdGlvbnMpIHtcbiAgICBvcHQgPSBvcHQgfHwge2RpbTogMn07XG4gICAgdGhpcy5wZXJwbGV4aXR5ID0gb3B0LnBlcnBsZXhpdHkgfHwgMzA7XG4gICAgdGhpcy5lcHNpbG9uID0gb3B0LmVwc2lsb24gfHwgMTA7XG4gICAgdGhpcy5ybmcgPSBvcHQucm5nIHx8IE1hdGgucmFuZG9tO1xuICAgIHRoaXMuZGltID0gb3B0LmRpbTtcbiAgICBpZiAob3B0LmRpbSA9PT0gMikge1xuICAgICAgdGhpcy5kaXN0MiA9IGRpc3QyXzJEO1xuICAgICAgdGhpcy5jb21wdXRlRm9yY2UgPSBjb21wdXRlRm9yY2VfMmQ7XG4gICAgfSBlbHNlIGlmIChvcHQuZGltID09PSAzKSB7XG4gICAgICB0aGlzLmRpc3QyID0gZGlzdDJfM0Q7XG4gICAgICB0aGlzLmNvbXB1dGVGb3JjZSA9IGNvbXB1dGVGb3JjZV8zZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDJEIGFuZCAzRCBpcyBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cbiAgLy8gdGhpcyBmdW5jdGlvbiB0YWtlcyBhIGZhdHRlbmVkIGRpc3RhbmNlIG1hdHJpeCBhbmQgY3JlYXRlc1xuICAvLyBtYXRyaXggUCBmcm9tIHRoZW0uXG4gIC8vIEQgaXMgYXNzdW1lZCB0byBiZSBwcm92aWRlZCBhcyBhbiBhcnJheSBvZiBzaXplIE5eMi5cbiAgaW5pdERhdGFEaXN0KFxuICAgIG5lYXJlc3Q6IHtcbiAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICBkaXN0OiBudW1iZXI7XG4gICAgfVtdW11cbiAgKSB7XG4gICAgbGV0IE4gPSBuZWFyZXN0Lmxlbmd0aDtcbiAgICB0aGlzLm5lYXJlc3QgPSBuZWFyZXN0O1xuICAgIHRoaXMuUCA9IG5lYXJlc3QyUChuZWFyZXN0LCB0aGlzLnBlcnBsZXhpdHksIDAuMDAwMSk7XG4gICAgdGhpcy5OID0gTjtcbiAgICB0aGlzLmluaXRTb2x1dGlvbigpOyAvLyByZWZyZXNoIHRoaXNcbiAgfVxuICAvLyAocmUpaW5pdGlhbGl6ZXMgdGhlIHNvbHV0aW9uIHRvIHJhbmRvbVxuICBpbml0U29sdXRpb24oKSB7XG4gICAgLy8gZ2VuZXJhdGUgcmFuZG9tIHNvbHV0aW9uIHRvIHQtU05FXG4gICAgdGhpcy5ZID0gcmFuZG5NYXRyaXgodGhpcy5OLCB0aGlzLmRpbSwgdGhpcy5ybmcpOyAvLyB0aGUgc29sdXRpb25cbiAgICB0aGlzLmdhaW5zID0gYXJyYXlvZnModGhpcy5OLCB0aGlzLmRpbSwgMSk7IC8vIHN0ZXAgZ2FpbnNcbiAgICAvLyB0byBhY2NlbGVyYXRlIHByb2dyZXNzIGluIHVuY2hhbmdpbmcgZGlyZWN0aW9uc1xuICAgIHRoaXMueXN0ZXAgPSBhcnJheW9mcyh0aGlzLk4sIHRoaXMuZGltLCAwKTsgLy8gbW9tZW50dW0gYWNjdW11bGF0b3JcbiAgICB0aGlzLml0ZXIgPSAwO1xuICB9XG4gIGdldERpbSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaW07XG4gIH1cbiAgLy8gcmV0dXJuIHBvaW50ZXIgdG8gY3VycmVudCBzb2x1dGlvblxuICBnZXRTb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ZO1xuICB9XG4gIC8vIEZvciBlYWNoIHBvaW50LCByYW5kb21seSBvZmZzZXQgcG9pbnQgd2l0aGluIGEgNSUgaHlwZXJzcGhlcmUgY2VudGVyZWRcbiAgLy8gYXJvdW5kIGl0LCB3aGlsc3QgcmVtYWluaW5nIGluIHRoZSBhc3N1bWVkIHQtU05FIHBsb3QgaHlwZXJzcGhlcmVcbiAgcGVydHVyYigpIHtcbiAgICBsZXQgTiA9IHRoaXMuTjtcbiAgICBsZXQgbWF4QXJlYSA9IDA7XG4gICAgbGV0IHltZWFuID0gdGhpcy5kaW0gPT09IDMgPyBbMCwgMCwgMF0gOiBbMCwgMF07XG4gICAgLy8gRGV0ZXJtaW5lIHJhZGl1cyBvZiB0LVNORSBoeXBlcnNwaGVyZSwgYXNzdW1lZCB6ZXJvIG1lYW4gYW5kIG5vcm1hbGl6ZWRcbiAgICAvLyBkaW1lbnNpb25zLiBIZXJlIGFyZWEgaXMgcHJvcG9ydGlvbmFsIHRvIHBpKnJhZGl1c14yLCB0byBza2lwIHJvb3QgY2FsYy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgbGV0IGFyZWEgPSAwO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLmRpbTsgKytkKSB7XG4gICAgICAgIGFyZWEgKz0gTWF0aC5wb3codGhpcy5ZW2kgKiB0aGlzLmRpbSArIGRdLCAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1heFJhZGl1cyA9IE1hdGgucG93KG1heEFyZWEsIDAuNSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGxldCBkaWZmID0gbmV3IEFycmF5KHRoaXMuZGltKTtcbiAgICAgIC8vIEZpbmQgYSBwZXJ0dXJiYXRpb24gb2YgcG9pbnQgdGhhdCBmaXRzIGluc2lkZSB0LVNORSBoeXBlcnNwaGVyZVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGFyZWEgPSAwO1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHRoaXMuZGltOyArK2QpIHtcbiAgICAgICAgICBkaWZmW2RdID0gMC4xICogbWF4UmFkaXVzICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgICAgICAgIGFyZWEgKz0gTWF0aC5wb3codGhpcy5ZW2kgKiB0aGlzLmRpbSArIGRdICsgZGlmZltkXSwgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZWEgPCBtYXhBcmVhKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5IG9mZnNldCB0byBwb2ludFxuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLmRpbTsgKytkKSB7XG4gICAgICAgIHRoaXMuWVtpICogdGhpcy5kaW0gKyBkXSArPSBkaWZmW2RdO1xuICAgICAgICB5bWVhbltkXSArPSB0aGlzLllbaSAqIHRoaXMuZGltICsgZF07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlcHJvamVjdCBZIHRvIGJlIHplcm8gbWVhblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHRoaXMuZGltOyArK2QpIHtcbiAgICAgICAgdGhpcy5ZW2kgKiB0aGlzLmRpbSArIGRdIC09IHltZWFuW2RdIC8gTjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gcGVyZm9ybSBhIHNpbmdsZSBzdGVwIG9mIG9wdGltaXphdGlvbiB0byBpbXByb3ZlIHRoZSBlbWJlZGRpbmdcbiAgc3RlcCgpIHtcbiAgICB0aGlzLml0ZXIgKz0gMTtcbiAgICBsZXQgTiA9IHRoaXMuTjtcbiAgICBsZXQgZ3JhZCA9IHRoaXMuY29zdEdyYWQodGhpcy5ZKTsgLy8gZXZhbHVhdGUgZ3JhZGllbnRcbiAgICAvLyBwZXJmb3JtIGdyYWRpZW50IHN0ZXBcbiAgICBsZXQgeW1lYW4gPSB0aGlzLmRpbSA9PT0gMyA/IFswLCAwLCAwXSA6IFswLCAwXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLmRpbTsgKytkKSB7XG4gICAgICAgIGxldCBnaWQgPSBncmFkW2ldW2RdO1xuICAgICAgICBsZXQgc2lkID0gdGhpcy55c3RlcFtpXVtkXTtcbiAgICAgICAgbGV0IGdhaW5pZCA9IHRoaXMuZ2FpbnNbaV1bZF07XG4gICAgICAgIC8vIGNvbXB1dGUgZ2FpbiB1cGRhdGVcbiAgICAgICAgbGV0IG5ld2dhaW4gPSBzaWduKGdpZCkgPT09IHNpZ24oc2lkKSA/IGdhaW5pZCAqIDAuOCA6IGdhaW5pZCArIDAuMjtcbiAgICAgICAgaWYgKG5ld2dhaW4gPCAwLjAxKSB7XG4gICAgICAgICAgbmV3Z2FpbiA9IDAuMDE7IC8vIGNsYW1wXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nYWluc1tpXVtkXSA9IG5ld2dhaW47IC8vIHN0b3JlIGZvciBuZXh0IHR1cm5cbiAgICAgICAgLy8gY29tcHV0ZSBtb21lbnR1bSBzdGVwIGRpcmVjdGlvblxuICAgICAgICBsZXQgbW9tdmFsID0gdGhpcy5pdGVyIDwgMjUwID8gMC41IDogMC44O1xuICAgICAgICBsZXQgbmV3c2lkID0gbW9tdmFsICogc2lkIC0gdGhpcy5lcHNpbG9uICogbmV3Z2FpbiAqIGdyYWRbaV1bZF07XG4gICAgICAgIHRoaXMueXN0ZXBbaV1bZF0gPSBuZXdzaWQ7IC8vIHJlbWVtYmVyIHRoZSBzdGVwIHdlIHRvb2tcbiAgICAgICAgLy8gc3RlcCFcbiAgICAgICAgbGV0IGlfZCA9IGkgKiB0aGlzLmRpbSArIGQ7XG4gICAgICAgIHRoaXMuWVtpX2RdICs9IG5ld3NpZDtcbiAgICAgICAgeW1lYW5bZF0gKz0gdGhpcy5ZW2lfZF07IC8vIGFjY3VtdWxhdGUgbWVhbiBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBjZW50ZXIgbGF0ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVwcm9qZWN0IFkgdG8gYmUgemVybyBtZWFuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICB0aGlzLllbaSAqIHRoaXMuZGltICsgZF0gLT0geW1lYW5bZF0gLyBOO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRTdXBlcnZpc2lvbihzdXBlcnZpc2VMYWJlbHM6IHN0cmluZ1tdLCBzdXBlcnZpc2VJbnB1dD86IHN0cmluZykge1xuICAgIGlmIChzdXBlcnZpc2VMYWJlbHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5sYWJlbHMgPSBzdXBlcnZpc2VMYWJlbHM7XG4gICAgICB0aGlzLmxhYmVsQ291bnRzID0ge307XG4gICAgICBsZXQgdW5pcXVlRW50cmllcyA9IEFycmF5LmZyb20obmV3IFNldChzdXBlcnZpc2VMYWJlbHMpKTtcbiAgICAgIHVuaXF1ZUVudHJpZXMuZm9yRWFjaCgobCkgPT4gKHRoaXMubGFiZWxDb3VudHNbbF0gPSAwKSk7XG4gICAgICBzdXBlcnZpc2VMYWJlbHMuZm9yRWFjaCgobCkgPT4gKHRoaXMubGFiZWxDb3VudHNbbF0gKz0gMSkpO1xuICAgIH1cbiAgICBpZiAoc3VwZXJ2aXNlSW5wdXQgIT0gbnVsbCkge1xuICAgICAgdGhpcy51bmxhYmVsZWRDbGFzcyA9IHN1cGVydmlzZUlucHV0O1xuICAgIH1cbiAgfVxuICBzZXRTdXBlcnZpc2VGYWN0b3Ioc3VwZXJ2aXNlRmFjdG9yOiBudW1iZXIpIHtcbiAgICBpZiAoc3VwZXJ2aXNlRmFjdG9yICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc3VwZXJ2aXNlRmFjdG9yID0gc3VwZXJ2aXNlRmFjdG9yO1xuICAgIH1cbiAgfVxuICAvLyByZXR1cm4gY29zdCBhbmQgZ3JhZGllbnQsIGdpdmVuIGFuIGFycmFuZ2VtZW50XG4gIGNvc3RHcmFkKFk6IEZsb2F0NjRBcnJheSk6IG51bWJlcltdW10ge1xuICAgIGxldCBOID0gdGhpcy5OO1xuICAgIGxldCBQID0gdGhpcy5QO1xuICAgIC8vIFRyaWNrIHRoYXQgaGVscHMgd2l0aCBsb2NhbCBvcHRpbWEuXG4gICAgbGV0IGFscGhhID0gdGhpcy5pdGVyIDwgMTAwID8gNCA6IDE7XG4gICAgbGV0IHN1cGVydmlzZUZhY3RvciA9IHRoaXMuc3VwZXJ2aXNlRmFjdG9yIC8gMTAwOyAvLyBzZXQgaW4gcmFuZ2UgWzAsIDFdXG4gICAgbGV0IHVubGFiZWxlZENsYXNzID0gdGhpcy51bmxhYmVsZWRDbGFzcztcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgbGV0IGxhYmVsQ291bnRzID0gdGhpcy5sYWJlbENvdW50cztcbiAgICBsZXQgc3VwZXJ2aXNlZCA9XG4gICAgICBzdXBlcnZpc2VGYWN0b3IgIT0gbnVsbCAmJlxuICAgICAgc3VwZXJ2aXNlRmFjdG9yID4gMCAmJlxuICAgICAgbGFiZWxzICE9IG51bGwgJiZcbiAgICAgIGxhYmVsQ291bnRzICE9IG51bGw7XG4gICAgbGV0IHVubGFiZWxlZENvdW50ID1cbiAgICAgIHN1cGVydmlzZWQgJiYgdW5sYWJlbGVkQ2xhc3MgIT0gbnVsbCAmJiB1bmxhYmVsZWRDbGFzcyAhPT0gJydcbiAgICAgICAgPyBsYWJlbENvdW50c1t1bmxhYmVsZWRDbGFzc11cbiAgICAgICAgOiAwO1xuICAgIC8vIE1ha2UgZGF0YSBmb3IgdGhlIFNQIHRyZWUuXG4gICAgbGV0IHBvaW50czogbnVtYmVyW11bXSA9IG5ldyBBcnJheShOKTsgLy8gKHgsIHkpW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgbGV0IGlUaW1lc0QgPSBpICogdGhpcy5kaW07XG4gICAgICBsZXQgcm93ID0gbmV3IEFycmF5KHRoaXMuZGltKTtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICByb3dbZF0gPSBZW2lUaW1lc0QgKyBkXTtcbiAgICAgIH1cbiAgICAgIHBvaW50c1tpXSA9IHJvdztcbiAgICB9XG4gICAgLy8gTWFrZSBhIHRyZWUuXG4gICAgbGV0IHRyZWUgPSBuZXcgU1BUcmVlKHBvaW50cyk7XG4gICAgbGV0IHJvb3QgPSB0cmVlLnJvb3QgYXMgQXVnbVNQTm9kZTtcbiAgICAvLyBBbm5vdGF0ZSB0aGUgdHJlZS5cbiAgICBsZXQgYW5ub3RhdGVUcmVlID0gKFxuICAgICAgbm9kZTogQXVnbVNQTm9kZVxuICAgICk6IHtcbiAgICAgIG51bUNlbGxzOiBudW1iZXI7XG4gICAgICB5Q2VsbDogbnVtYmVyW107XG4gICAgfSA9PiB7XG4gICAgICBsZXQgbnVtQ2VsbHMgPSAxO1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgbm9kZSBhbmQgdGVsbCB0aGUgcGFyZW50LlxuICAgICAgICBub2RlLm51bUNlbGxzID0gbnVtQ2VsbHM7XG4gICAgICAgIG5vZGUueUNlbGwgPSBub2RlLnBvaW50O1xuICAgICAgICByZXR1cm4ge251bUNlbGxzLCB5Q2VsbDogbm9kZS55Q2VsbH07XG4gICAgICB9XG4gICAgICAvLyBub2RlLnBvaW50IGlzIGEgMiBvciAzLWRpbSBudW1iZXJbXSwgc28gc2xpY2UoKSBtYWtlcyBhIGNvcHkuXG4gICAgICBsZXQgeUNlbGwgPSBub2RlLnBvaW50LnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gYW5ub3RhdGVUcmVlKGNoaWxkIGFzIEF1Z21TUE5vZGUpO1xuICAgICAgICBudW1DZWxscyArPSByZXN1bHQubnVtQ2VsbHM7XG4gICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5kaW07ICsrZCkge1xuICAgICAgICAgIHlDZWxsW2RdICs9IHJlc3VsdC55Q2VsbFtkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIHRoZSBub2RlIGFuZCB0ZWxsIHRoZSBwYXJlbnQuXG4gICAgICBub2RlLm51bUNlbGxzID0gbnVtQ2VsbHM7XG4gICAgICBub2RlLnlDZWxsID0geUNlbGwubWFwKCh2KSA9PiB2IC8gbnVtQ2VsbHMpO1xuICAgICAgcmV0dXJuIHtudW1DZWxscywgeUNlbGx9O1xuICAgIH07XG4gICAgLy8gQXVnbWVudCB0aGUgdHJlZSB3aXRoIG1vcmUgaW5mby5cbiAgICBhbm5vdGF0ZVRyZWUocm9vdCk7XG4gICAgdHJlZS52aXNpdCgobm9kZTogQXVnbVNQTm9kZSwgbG93OiBudW1iZXJbXSwgaGlnaDogbnVtYmVyW10pID0+IHtcbiAgICAgIG5vZGUuckNlbGwgPSBoaWdoWzBdIC0gbG93WzBdO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIC8vIGNvbXB1dGUgY3VycmVudCBRIGRpc3RyaWJ1dGlvbiwgdW5ub3JtYWxpemVkIGZpcnN0XG4gICAgbGV0IGdyYWQ6IG51bWJlcltdW10gPSBbXTtcbiAgICBsZXQgWiA9IDA7XG4gICAgbGV0IHN1bV9waWogPSAwO1xuICAgIGxldCBmb3JjZXM6IFtudW1iZXJbXSwgbnVtYmVyW11dW10gPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGxldCBwb2ludEkgPSBwb2ludHNbaV07XG4gICAgICBpZiAoc3VwZXJ2aXNlZCkge1xuICAgICAgICB2YXIgc2FtZUNvdW50ID0gbGFiZWxDb3VudHNbbGFiZWxzW2ldXTtcbiAgICAgICAgdmFyIG90aGVyQ291bnQgPSBOIC0gc2FtZUNvdW50IC0gdW5sYWJlbGVkQ291bnQ7XG4gICAgICB9XG4gICAgICAvLyBDb21wdXRlIHRoZSBwb3NpdGl2ZSBmb3JjZXMgZm9yIHRoZSBpLXRoIG5vZGUuXG4gICAgICBsZXQgRnBvcyA9IHRoaXMuZGltID09PSAzID8gWzAsIDAsIDBdIDogWzAsIDBdO1xuICAgICAgbGV0IG5laWdoYm9ycyA9IHRoaXMubmVhcmVzdFtpXTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbmVpZ2hib3JzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxldCBqID0gbmVpZ2hib3JzW2tdLmluZGV4O1xuICAgICAgICBsZXQgcGlqID0gUFtpICogTiArIGpdO1xuICAgICAgICAvLyBhcHBseSBzZW1pLXN1cGVydmlzZWQgcHJpb3IgcHJvYmFiaWxpdGllc1xuICAgICAgICBpZiAoc3VwZXJ2aXNlZCkge1xuICAgICAgICAgIGlmIChsYWJlbHNbaV0gPT09IHVubGFiZWxlZENsYXNzIHx8IGxhYmVsc1tqXSA9PT0gdW5sYWJlbGVkQ2xhc3MpIHtcbiAgICAgICAgICAgIHBpaiAqPSAxIC8gTjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsc1tpXSAhPT0gbGFiZWxzW2pdKSB7XG4gICAgICAgICAgICBwaWogKj0gTWF0aC5tYXgoMSAvIE4gLSBzdXBlcnZpc2VGYWN0b3IgLyBvdGhlckNvdW50LCAxZS03KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsc1tpXSA9PT0gbGFiZWxzW2pdKSB7XG4gICAgICAgICAgICBwaWogKj0gTWF0aC5taW4oMSAvIE4gKyBzdXBlcnZpc2VGYWN0b3IgLyBzYW1lQ291bnQsIDEgLSAxZS03KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VtX3BpaiArPSBwaWo7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvaW50SiA9IHBvaW50c1tqXTtcbiAgICAgICAgbGV0IHNxdWFyZWREaXN0SXRvSiA9IHRoaXMuZGlzdDIocG9pbnRJLCBwb2ludEopO1xuICAgICAgICBsZXQgcHJlbXVsdCA9IHBpaiAvICgxICsgc3F1YXJlZERpc3RJdG9KKTtcbiAgICAgICAgdGhpcy5jb21wdXRlRm9yY2UoRnBvcywgcHJlbXVsdCwgcG9pbnRJLCBwb2ludEopO1xuICAgICAgfVxuICAgICAgLy8gQ29tcHV0ZSB0aGUgbmVnYXRpdmUgZm9yY2VzIGZvciB0aGUgaS10aCBub2RlLlxuICAgICAgbGV0IEZuZWdaID0gdGhpcy5kaW0gPT09IDMgPyBbMCwgMCwgMF0gOiBbMCwgMF07XG4gICAgICB0cmVlLnZpc2l0KChub2RlOiBBdWdtU1BOb2RlKSA9PiB7XG4gICAgICAgIGxldCBzcXVhcmVkRGlzdFRvQ2VsbCA9IHRoaXMuZGlzdDIocG9pbnRJLCBub2RlLnlDZWxsKTtcbiAgICAgICAgLy8gU3F1YXJlZCBkaXN0YW5jZSBmcm9tIHBvaW50IGkgdG8gY2VsbC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPT0gbnVsbCB8fFxuICAgICAgICAgIChzcXVhcmVkRGlzdFRvQ2VsbCA+IDAgJiZcbiAgICAgICAgICAgIG5vZGUuckNlbGwgLyBNYXRoLnNxcnQoc3F1YXJlZERpc3RUb0NlbGwpIDwgVEhFVEEpXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBxaWpaID0gMSAvICgxICsgc3F1YXJlZERpc3RUb0NlbGwpO1xuICAgICAgICAgIGxldCBkWiA9IG5vZGUubnVtQ2VsbHMgKiBxaWpaO1xuICAgICAgICAgIFogKz0gZFo7XG4gICAgICAgICAgZFogKj0gcWlqWjtcbiAgICAgICAgICB0aGlzLmNvbXB1dGVGb3JjZShGbmVnWiwgZFosIHBvaW50SSwgbm9kZS55Q2VsbCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2VsbCBpcyB0b28gY2xvc2UgdG8gYXBwcm94aW1hdGUuXG4gICAgICAgIGxldCBzcXVhcmVkRGlzdFRvUG9pbnQgPSB0aGlzLmRpc3QyKHBvaW50SSwgbm9kZS5wb2ludCk7XG4gICAgICAgIGxldCBxaWpaID0gMSAvICgxICsgc3F1YXJlZERpc3RUb1BvaW50KTtcbiAgICAgICAgWiArPSBxaWpaO1xuICAgICAgICBxaWpaICo9IHFpalo7XG4gICAgICAgIHRoaXMuY29tcHV0ZUZvcmNlKEZuZWdaLCBxaWpaLCBwb2ludEksIG5vZGUucG9pbnQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGZvcmNlc1tpXSA9IFtGcG9zLCBGbmVnWl07XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgbmVnYXRpdmUgZm9yY2VzIGFuZCBjb21wdXRlIHRoZSBncmFkaWVudC5cbiAgICBsZXQgQSA9IDQgKiBhbHBoYTtcbiAgICBpZiAoc3VwZXJ2aXNlZCkge1xuICAgICAgQSAvPSBzdW1fcGlqO1xuICAgIH1cbiAgICBjb25zdCBCID0gNCAvIFo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgIGxldCBbRlBvcywgRk5lZ1pdID0gZm9yY2VzW2ldO1xuICAgICAgbGV0IGdzdW0gPSBuZXcgQXJyYXkodGhpcy5kaW0pO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLmRpbTsgKytkKSB7XG4gICAgICAgIGdzdW1bZF0gPSBBICogRlBvc1tkXSAtIEIgKiBGTmVnWltkXTtcbiAgICAgIH1cbiAgICAgIGdyYWQucHVzaChnc3VtKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbn1cbiJdfQ==