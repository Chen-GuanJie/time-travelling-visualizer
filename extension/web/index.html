<!DOCTYPE html>
<html>

<head>
    <title>TIME-TRAVELLING</title>
    <meta charset="UTF-8" name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <link rel="stylesheet" href="driver.min.css">
    <link rel="stylesheet" href="index.css">
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3/dist/js.cookie.min.js"></script>
    <!-- <script src="https://unpkg.com/element-ui/lib/index.js"></script>   -->
    <!-- <script src="https://cdn.bootcss.com/vue/2.5.16/vue.min.js"></script> -->
    <script src="thirdParty/vue.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <script src="thirdParty/d3.v5.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script> -->
    <script src="thirdParty/three.min.js"></script>
    <script src="request.js"></script>
    <script src="render.js"></script>
    <script src="utils.js"></script>
    <script src="message.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <style>
        body, html {
            height: 100%;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/driver.js/dist/driver.min.js"></script>
    <div id="app" v-loading="isCanvasLoading" element-loading-text="loading..." element-loading-background="rgba(255, 255, 255, 0.4)">
        <div class="content_container">
            <div id="container_range">
                <div id="container">            
                </div>
            </div>
            <div id="footer">
                <div>Epochs</div>
                <svg id="timeLinesvg" height="0" width="0"></svg>
            </div>         
        </div>
        <div id="subject_model_info_panel">
            <div id="labelsSection">
                <div>Labels</div>
                <div v-if="label_name_dict" id="labelList">
                    <div v-for="labelNum in Object.keys(label_name_dict)"
                    @mouseover="setColorPickerOpacity($event.currentTarget, labelNum, 1)"
                    @mouseleave="setColorPickerOpacity($event.currentTarget, labelNum, 0)">
                        <span :style="'color: ' + translateCssColor(color_list[labelNum]) + ';'">{{ label_name_dict[labelNum] }}</span>
                        <input type="color" :value="translateCssColor(color_list[labelNum])" :id="'color-picker-item-' + labelNum"
                        @input="changeLabelColor(parseInt(labelNum), hexToRgbArray($event.target.value))">
                    </div>
                </div>
            </div>   
        </div>

        <div id="hoverLabel">
            <!-- Label content -->
        </div>
        <div id="fixedHoverLabel">

        </div>
    </div>
</body>

<script>

    window.vueApp = new Vue(
        {
        el: '#app',
        data() {
            return {
                selectedList:[{'index':22},{'index':77}],
                selectedIndex: [],
                selectedPointPos:[],
                selectedPointPos: [],
                showModal: false,
                lastHoveredIndex: null,
                curIndex:null,
                nnIndices: [],
                contentPath: ' ',
                customContentPath: '',
                visMethod: 'Trustvis',
                taskType: 'Classification',
                colorType: 'noColoring',
                showColorSetting: false,
                filter_index:'',
                isCanvasLoading: false,
                query_result: {},
                prediction_list: [],
                curr_pred: '',
                curr_label: '',
                label_list: [],
                label_name_dict: {},
                color_list: [],
                confidence_list: [],
                confidence_dict: [],
                evaluation: { test_acc: 0, train_acc: 0 },
                currEpoch: 1,
                totalEpoch: null,
                train_index: null,
                test_index: null,
                showTraining: true,
                showTesting: true,
                showVisError: false,
                showPredictionFlips: false,
                SelectionMode: false,
                isShifting: false,
                scene: null,
                renderer: null,
                camera: null,
                curImg: null,
                imageSrc: "",
                textContent: "",
                dataType: "Image",
                timelineFirstLoaded: false,

                visibilityMap: null,
                highlightAttributes: {
                    visualizationError: null,
                },
                predictionFlipIndices: null,
                hoverIndex: null,
                errorMessage: null,
                originalSettings: {
                    originalColors: null,
                    originalSizes: null,
                },
                pointsMesh: null,
                canvasSetting: {
                    zoomSpeed: 0.01,
                    dragSpeed: 0.1,
                    panSpeed: 0.1,
                },
                predicates: {
                    key: 'lable',
                    value: null
                },
                query: {
                    key: 'index',
                    value: null,
                    k: null
                },
                isSwitchOn: false,
                confidence: [0, 1],
                sceneBoundary: {
                    x_min: null,
                    y_min: null,
                    x_max: null,
                    y_max: null 
                },
                indexUpdateLock: undefined,

                validLabelList: []
            }
        },
        created(){
            this.loadCookies()
        },
        methods: {
            setColorPickerOpacity(target, labelNumber, value) {
                const colorPickerItem = target.querySelector('#color-picker-item-' + labelNumber);
                if (value) {
                    colorPickerItem.style.opacity='1';
                    colorPickerItem.style.pointerEvents='auto';
                } else {
                    colorPickerItem.style.opacity='0';
                    colorPickerItem.style.pointerEvents='none';
                }
            },
            changeLabelColor(labelNumber, newColor) {
                const color_list = this.color_list;
                for (let i = 0; i < color_list.length; ++i) {
                    if (i === labelNumber) {
                        this.$set(color_list, i, newColor);
                    }
                }
                this.plotCanvas?.updateColor();
            },
            hexToRgbArray(hex)  {
                hex = hex.replace(/^#/, '');
                let bigint = parseInt(hex, 16);
                let r = (bigint >> 16) & 255;
                let g = (bigint >> 8) & 255;
                let b = bigint & 255;
                return [r, g, b];
            },
            translateCssColor(rgbArray) {
                return '#' + rgbArray.map(c => c.toString(16).padStart(2, '0')).join('');
            },
            loadCookies(){
                this.contentPath = Cookies.get('contentPath') || '';
            },
            deleteItemfromSel(item) {
                const index = this.selectedIndex.indexOf(item);
                if (index !== -1) {
                  this.selectedIndex.splice(index, 1);
                }
              },
            saveContentPath(){
                Cookies.set('contentPath', this.contentPath, { expires: 7 }); // Expires in 7 days
            },
            filterByIndex(){
                this.updateProjectionHandler()
            },
            update() {
                this.timelineFirstLoaded = true
                this.isCanvasLoading = true
                console.log("taskType", this.taskType)
                fetchTimelineData(this.contentPath, "")
                    .catch(error => {
                        console.log(error);
                    })
                    .then(res => {
                        if (this.customContentPath != '') {
                            updateCustomProjection(this.contentPath, this.customContentPath, this.currEpoch, this.taskType)
                        }
                        else{
                            console.log(`content: ${this.contentPath}`)
                            this.updateProjectionHandler()
                        }
                    })
            },
            updateProjectionHandler() {
                if (!this.timelineFirstLoaded) {
                    this.update();
                } else {
                    this.isCanvasLoading = true;
                    updateProjection(this.contentPath, this.currEpoch, this.taskType)
                }
            },
            indexSearchHandler() {
                this.isCanvasLoading = true
                indexSearch(this.query, this.isSwitchOn);
            },
            clearSearchHandler() {
                clear();
            },
            openModal() {
                this.showModal = true;
            },
            saveChanges() {
                console.log('保存更改:', this.selectedIndex);
                this.showModal = false;
            },
            setShowModalFalse() {
                this.showModal = false;
            },
        },
        watch: {
            contentPath(newVal) {
                this.saveContentPath();
              },
            // TODO Why are lastHoveredIndex and curIndex separated?
            lastHoveredIndex: {
                immediate: true,
                handler(newVal, oldVal) {
                    if (newVal != null) {
                        // TODO Must this be resolved only when awaited?
                        this.indexUpdateLock = new Promise((resolve, reject) => {
                            // FIXME this is not good to filter the index of that type. Use global type, also changing the backend!
                            // const idx = this.typeIndexList[newVal]; 
                            getOriginalData(this.contentPath, newVal, this.dataType, "", this.customContentPath, this.curr_label).then(resolve);
                        });
                        const updatedQuery = {
                            ...this.query,
                            key: 'index',
                            value: newVal
                        };
                        if (this.isSwitchOn) {
                            indexSearch(updatedQuery, this.isSwitchOn);
                        }
                    }
                }
            },
            curIndex:{
                immediate: true,
                async handler(newVal, oldVal) {
                    if (this.indexUpdateLock) {
                        await this.indexUpdateLock;
                        this.indexUpdateLock = undefined;
                    }
                    if (this.filter_index !== null && this.filter_index !== "" && (!Array.isArray(this.filter_index) || this.filter_index.length !== 0)) {
                        let filter_index = window.vueApp.filter_index.split(',');
                        // console.log("filter_index[newVal]", filter_index[newVal])
                        this.curr_pred = this.prediction_list[newVal];
                    } else {
                        // console.log("newVal", newVal)
                        this.curr_pred = this.prediction_list[newVal];
                    }
                    this.curr_label = this.label_name_dict[this.label_list[newVal]];
                    this.confidence_dict = this.confidence_list[newVal]

                    const data_point_data = getKeysData(this, [
                        'lastHoveredIndex', 'curr_pred', 'curr_label', 'confidence_dict', 'dataType', 'imageSrc', 'textContent'
                    ]);
                    sendMessage({
                        command: 'updateDataPoint',
                        ...data_point_data
                    });
                }
            },

            showVisError: {
                immediate: true,
                handler(newVal, oldVal) {
                    if (newVal) {
                        getHighlightedPoints('visError', '')
                        setTimeout(() => {
                            this.updateProjectionHandler()
                        }, 1000);
                    } else {
                        if (this.highlightAttributes.visualizationError) {
                            this.highlightAttributes.visualizationError.clear()
                        }
                        this.highlightAttributes.visualizationError = null
                    }
                }
            },
            showPredictionFlips: {
                handler(newVal, oldVal) {
                    // prediction flip check for next epoch only
                    console.log("newVal", newVal, this.currEpoch,  this.totalEpoch)
                    if (newVal && this.currEpoch < this.totalEpoch) {
                        getPredictionFlipIndices('')
                        setTimeout(() => {
                            this.updateProjectionHandler()
                        }, 1000);
                    } else {
                        console.log("else branch")
                        this.predictionFlipIndices = null
                    }
                }
            },
            taskType: {
                handler(newVal, oldVal) {
                    if (newVal == "Non-Classification") {
                        this.showColorSetting = true
                    } else {
                        this.showColorSetting = false
                    }
                }
            }
        },
        mounted() {
            this.driver = new Driver();
            sendMessage({ state: 'load', forward: true });
        }
    })
</script>

</html>