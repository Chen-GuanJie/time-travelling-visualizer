<!DOCTYPE html>
<html>

<head>
    <title>TIME-TRAVELLING</title>
    <meta charset="UTF-8" name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <link rel="stylesheet" href="driver.min.css">
    <link rel="stylesheet" href="index.css">
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3/dist/js.cookie.min.js"></script>
    <!-- <script src="https://unpkg.com/element-ui/lib/index.js"></script>   -->
    <!-- <script src="https://cdn.bootcss.com/vue/2.5.16/vue.min.js"></script> -->
    <script src="thirdParty/vue.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <script src="thirdParty/d3.v5.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script> -->
    <script src="thirdParty/three.min.js"></script>
    <script src="request.js"></script>
    <script src="render.js"></script>
    <script src="utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <style>
        body, html {
            height: 100%;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/driver.js/dist/driver.min.js"></script>
    <div id="app" v-loading="isCanvasLoading" element-loading-text="loading..." element-loading-background="rgba(255, 255, 255, 0.4)">
        <div class="header">
            Time Travelling Visualizer
            <a href="/contrast" @click="clearStorageNavigate(event,'/contrast')"style="color: #fff; position:fixed; right: 60px;top:4px;"><i class="el-icon-open"
                    style="font-size: 24px;"></i></a>
            <a id="connectUs" href="mailto:zyifan828@gmail.com?subject=Time Travelling visualizer Bug&body=Hi"
                style="color: #fff; position:fixed; right: 20px;top:4px;"><i class="el-icon-message"
                    style="font-size: 24px;"></i></a>
        </div>
        <!-- <el-button class="tutorial_btn" type="success" icon="el-icon-question" size="mini"
            @click.prevent.stop="guide"></el-button>
        <el-popover placement="left" width="200" trigger="click">
            <div>
                <span style="line-height: 40px; font-weight: 800;">Canvas Intereaction</span>
                <br />
                <div class="setting-item">
                    <span>Zoom Speed:</span> <el-input @input="filterInput('zoomSpeed', $event)" style="width: 100px;"
                        size="mini" v-model="canvasSetting.zoomSpeed"></el-input>
                </div>
                <div class="setting-item">
                    <el-button size="mini" @click="resetCamera">Reset Camera</el-button>
                </div>
            </div>
            <el-button style="position: absolute; top: 120px; right:0; font-size: 20px;" size="mini" type="warning"
                slot="reference" icon="el-icon-setting"></el-button>
        </el-popover>

        <el-popover placement="left" width="200" trigger="click">
            <div>
                <span style="line-height: 40px; font-weight: 800;">Error Message</span>
                <br />
                <div class="error-message-content" style="margin: 10px 0;">
                    {{ errorMessage }}
                </div>
            </div>
            <el-button style="position: absolute; top: 160px; right:0; font-size: 20px;" size="mini" type="danger"
                slot="reference" icon="el-icon-warning"></el-button>
        </el-popover> -->

        <div class="content_container">
            <div id="subject_model_info_panel">
                <table id="labelColor">
                    <thead>
                        <tr>
                            <th>Label</th>
                            <th>Color</th>
                        </tr>
                    </thead>
                    <tbody>
    
                    </tbody>
                </table>
    
            </div>            
            <div id="container">            
            </div>

        </div>
        <div id="footer">
            <svg id="timeLinesvg" height="0" width="0"></svg>
        </div>
        <div id="currHover">
            <h3>MetaData Card</h3>
            HoverIndex: {{lastHoveredIndex}}<br />
            Prediction: {{curr_pred}}<br />
            Label: {{curr_label}}<br />
            Confidence: {{confidence_dict}}<br />
            <div v-if="dataType === 'Image' && lastHoveredIndex != null">
                <img :src="imageSrc" alt="Image Description" height="100px" />
            </div>
            <div v-else>
                <div style="overflow-y: auto; white-space: pre;">
                    <p>{{ textContent }}</p>
                </div>
            </div>
        </div>
        <div id="hoverLabel">
            <!-- Label content -->
        </div>
        <div id="fixedHoverLabel">

        </div>
    </div>
</body>

<script>

    window.vueApp = new Vue({
        el: '#app',
        data() {
            return {
                selectedList:[{'index':22},{'index':77}],
                selectedIndex: [],
                selectedPointPos:[],
                selectedPointPos: [],
                showModal: false,
                lastHoveredIndex: null,
                curIndex:null,
                nnIndices: [],
                contentPath: ' ',
                customContentPath: '',
                visMethod: 'Trustvis',
                taskType: 'Classification',
                colorType: 'noColoring',
                showColorSetting: false,
                filter_index:'',
                isCanvasLoading: false,
                query_result: {},
                prediction_list: [],
                curr_pred: '',
                curr_label: '',
                label_list: [],
                label_name_dict: {},
                color_list: [],
                confidence_list: [],
                confidence_dict: [],
                evaluation: { test_acc: 0, train_acc: 0 },
                currEpoch: 1,
                totalEpoch: null,
                train_index: null,
                test_index: null,
                showTraining: true,
                showTesting: true,
                showVisError: false,
                showPredictionFlips: false,
                SelectionMode: false,
                isShifting: false,
                scene: null,
                renderer: null,
                camera: null,
                curImg: null,
                imageSrc: "",
                textContent: "",
                dataType: "Image",
                timelineFirstLoaded: false,

                visibilityMap: null,
                highlightAttributes: {
                    visualizationError: null,
                },
                predictionFlipIndices: null,
                hoverIndex: null,
                errorMessage: null,
                originalSettings: {
                    originalColors: null,
                    originalSizes: null,
                },
                pointsMesh: null,
                canvasSetting: {
                    zoomSpeed: 0.01,
                    dragSpeed: 0.1,
                    panSpeed: 0.1,
                },
                predicates: {
                    key: 'lable',
                    value: null
                },
                query: {
                    key: 'index',
                    value: null,
                    k: null
                },
                isSwitchOn: false,
                confidence: [0, 1],
                sceneBoundary: {
                    x_min: null,
                    y_min: null,
                    x_max: null,
                    y_max: null 
                }
            }
        },
        created(){
            this.loadCookies()
        },
        methods: {
            loadCookies(){
                this.contentPath = Cookies.get('contentPath') || '';
            },
            deleteItemfromSel(item) {
                const index = this.selectedIndex.indexOf(item);
                if (index !== -1) {
                  this.selectedIndex.splice(index, 1);
                }
              },
            saveContentPath(){
                Cookies.set('contentPath', this.contentPath, { expires: 7 }); // Expires in 7 days
            },
            filterInput(key, event) {
                console.log(key, event)
                let value = event

                value = value.replace(/[^0-9.]/g, '').replace(/(\..*?)\..*/g, '$1');

                if ((value.match(/\./g) || []).length > 1) {
                    value = value.replace(/\.$/, '');
                }
                this.canvasSetting[key] = value;
            },
            resetCamera() {
                const target = new THREE.Vector3(
                    0, 0, 0
                );
                container = document.getElementById("container")
                const rect = container.getBoundingClientRect();
                var aspectRatio = rect.width / rect.height;
              
                this.camera.position.set(0, 0, 100);
                this.camera.left = this.sceneBoundary.x_min * aspectRatio
                this.camera.right = this.sceneBoundary.x_max * aspectRatio;
                this.camera.top = this.sceneBoundary.y_max;
                this.camera.bottom = this.sceneBoundary.y_min;
  
                this.renderer.setSize(rect.width, rect.height);
                this.renderer.setClearColor(BACKGROUND_COLOR, 1);

                const viewportWidth = this.renderer.domElement.clientWidth;
                const viewportHeight = this.renderer.domElement.clientHeight;

                this.camera.zoom = 1;
                this.camera.updateProjectionMatrix();
                this.camera.lookAt(target);
            },
            filterByIndex(){
                this.updateProjectionHandler()
            },
            NlSearch(){
            },
            guide() {
                const steps = [
                    // {
                    //     element: '#connectUs',
                    //     popover: {
                    //         title: 'Connect Us',
                    //         description: '**************',
                    //         position: 'left'
                    //     },
                    // },
                    {
                        element: '#contentSettingData',
                        popover: {
                            title: 'Data Type Selection',
                            description: 'Please choose the data type used by the subject model',
                            position: 'right'
                        },
                    },
                    {
                        element: '#contentSettingTask',
                        popover: {
                            title: 'Task Type Selection',
                            description: 'Please choose whether your subject model is used for classification or not',
                            position: 'right'
                        },
                    },
                    {
                        element: '#taskType',
                        popover: {
                            title: 'Content Path',
                            description: 'Please input the absolute path of the training/testing dynamics',
                            position: 'right'
                        },
                    },
                    {
                        element: '#contentPathInput',
                        popover: {
                            title: 'Content Path',
                            description: 'Please input the absolute path of the training/testing dynamics',
                            position: 'right'
                        },
                    },
                    {
                        element: '#showVisResBtn',
                        popover: {
                            title: 'Load Visualization Results',
                            description: 'After input the content path, you can click this to load the visulization results(default start from epoch 1)',
                            position: 'right'
                        },
                    },
                    {
                        element: '#footer',
                        popover: {
                            title: 'Time Line',
                            description: 'It shows the total number of epochs of loaded training/testing dynamics',
                            position: 'top',
                        },
                    },
                    {
                        element: '#subjectModeEvalRes',
                        popover: {
                            title: 'Subject Model Eval Result',
                            description: 'After load the visualization result, the corresponding training and testing accuracies wiil be shown here',
                            position: 'right'
                        },
                    },
                    {
                        element: '#currHover',
                        popover: {
                            title: 'Hover Information',
                            description: 'The detail of the current hover sample will be shown here',
                            position: 'right'
                        },
                    },
                    {
                        element: '#container',
                        popover: {
                            title: 'Visualization Canvas',
                            description: 'It shows the interactable 2D embedding space generated by your previously used visualization techniques',
                            position: 'right'
                        },
                    },
                    {
                        element: '#advanced_panel',
                        popover: {
                            title: 'Advanced panel',
                            description: 'You can input proper value to query data points you interested in',
                            position: 'left'
                        },
                    }

                ]
                this.driver.defineSteps(steps)
                this.driver.start()
            },
            update() {
                this.timelineFirstLoaded = true
                this.isCanvasLoading = true
                console.log("taskType", this.taskType)
                if (this.customContentPath != '') {
                    updateCustomProjection(this.contentPath, this.customContentPath, this.currEpoch, this.taskType)
                }
                else{
                    console.log(`content: ${this.contentPath}`)
                    this.updateProjectionHandler()
                }
                fetchTimelineData(this.contentPath, "")
            },
            updateProjectionHandler() {
                if (!this.timelineFirstLoaded) {
                    this.update();
                } else {
                    this.isCanvasLoading = true;
                    updateProjection(this.contentPath, this.currEpoch, this.taskType)
                }
            },
            VDBHandler() {
                this.isCanvasLoading = true
                loadVectorDB(this.contentPath, this.currEpoch)
            },
            ColorHandler() {
                this.isCanvasLoading = true  
                reloadColor('')   
            },
            indexSearchHandler() {
                this.isCanvasLoading = true
                indexSearch(this.query, this.isSwitchOn);
            },
            clearSearchHandler() {
                clear();
            },
            toggleSwitch() {
                this.isSwitchOn = !this.isSwitchOn; // 切换开关状态
                console.log(this.isSwitchOn)
            },
            openModal() {
                this.showModal = true;
            },
            saveChanges() {
                console.log('保存更改:', this.selectedIndex);
                this.showModal = false;
            },
            getInitialState() {
                return {lastHoveredIndex: null,
                contentPath: '/home/yifan/dataset/case_study_mnist_backdoor',
                customContentPath: '',
                visMethod: 'Trustvis',
                taskType: 'Classification',
                colorType: 'noColoring',
                showColorSetting: false,
                isCanvasLoading: false,
                query_result: {},
                prediction_list: [],
                curr_pred: '',
                curr_label: '',
                label_list: [],
                label_name_dict: {},
                color_list: [],
                confidence_list: [],
                confidence_dict: [],
                evaluation: { test_acc: 0, train_acc: 0 },
                currEpoch: 1,
                totalEpoch: null,
                train_index: null,
                test_index: null,
                showTraining: true,
                showTesting: true,
                showVisError: false,
                showPredictionFlips: false,
                SelectionMode: false,
                isShifting: false,
                scene: null,
                renderer: null,
                camera: null,
                curImg: null,
                imageSrc: "",
                textContent: "",
                dataType: "Image",
                visibilityMap: null,
                highlightAttributes: {
                    visualizationError: null,
                },
                predictionFlipIndices: null,
                hoverIndex: null,
                errorMessage: null,
                originalSettings: {
                    originalColors: null,
                    originalSizes: null,
                },
                pointsMesh: null,
                canvasSetting: {
                    zoomSpeed: 0.01,
                    dragSpeed: 0.1,
                    panSpeed: 0.1,
                },
                predicates: {
                    key: 'lable',
                    value: null
                },
                query: {
                    key: 'index',
                    value: null,
                    k: null
                },
                isSwitchOn: false,
                confidence: [0, 1],
                sceneBoundary: {
                    x_min: null,
                    y_min: null,
                    x_max: null,
                    y_max: null 
                }
            };
            },

            resetData() {
                Object.assign(this.$data, this.getInitialState());
            },
            clearStorageNavigate(event, url) {
                event.preventDefault();

                localStorage.clear();
                sessionStorage.clear(); 
                cleanForEpochChange('');
                this.resetData();

                window.location.href = url
            },
            setShowModalFalse() {
                this.showModal = false;
            },
        },
        watch: {
            contentPath(newVal) {
                this.saveContentPath();
              },
            lastHoveredIndex: {
                immediate: true,
                handler(newVal, oldVal) {
                    if (newVal != null) {
                        getOriginalData(this.contentPath, newVal, this.dataType, "", this.customContentPath)
                        const updatedQuery = {
                            ...this.query,
                            key: 'index',
                            value: newVal
                        };
                        if (this.isSwitchOn) {
                            indexSearch(updatedQuery, this.isSwitchOn);
                        }

                    }
                }
            },
            curIndex:{
                immediate: true,
                handler(newVal, oldVal) {
                    if (this.filter_index !== null && this.filter_index !== "" && (!Array.isArray(this.filter_index) || this.filter_index.length !== 0)) {
                        let filter_index = window.vueApp.filter_index.split(',');
                        console.log("filter_index[newVal]", filter_index[newVal])
                        this.curr_pred = this.prediction_list[filter_index[newVal]];
                    } else {
                        console.log("newVal", newVal)
                        this.curr_pred = this.prediction_list[newVal];
                    }
                    this.curr_label = this.label_name_dict[this.label_list[newVal]];
                    this.confidence_dict = this.confidence_list[newVal]
                }
            },

            showVisError: {
                immediate: true,
                handler(newVal, oldVal) {
                    if (newVal) {
                        getHighlightedPoints('visError', '')
                        setTimeout(() => {
                            this.updateProjectionHandler()
                        }, 1000);
                    } else {
                        if (this.highlightAttributes.visualizationError) {
                            this.highlightAttributes.visualizationError.clear()
                        }
                        this.highlightAttributes.visualizationError = null
                    }
                }
            },
            showPredictionFlips: {
                handler(newVal, oldVal) {
                    // prediction flip check for next epoch only
                    console.log("newVal", newVal, this.currEpoch,  this.totalEpoch)
                    if (newVal && this.currEpoch < this.totalEpoch) {
                        getPredictionFlipIndices('')
                        setTimeout(() => {
                            this.updateProjectionHandler()
                        }, 1000);
                    } else {
                        console.log("else branch")
                        this.predictionFlipIndices = null
                    }
                }
            },
            taskType: {
                handler(newVal, oldVal) {
                    if (newVal == "Non-Classification") {
                        this.showColorSetting = true
                    } else {
                        this.showColorSetting = false
                    }
                }
            }
        },
        mounted() {
            this.driver = new Driver()
        }
    })

    window.addEventListener('message', msg => {
        console.log("Yeeeeeeeeeeeeeeeeeeeeeeee");
        console.log(msg.data);
        const data = msg.data;
        if (!data) {
            return;
        }
        if (validCommands.includes(data.command) || data.command == 'sync') {
            for (const key in data) {
                if (!(keyKeys.includes(key))) {
                    window.vueApp[key] = data[key];
                }
            }
            if (data.command == 'sync') {
                window.vueApp.$forceUpdate();
                return;
            }
            if (data.args) {
                window.vueApp[data.command](...data.args);
            } else {
                window.vueApp[data.command]();
            }
            console.log("Main view data:", window.vueApp.$data);
        }
    });
</script>

</html>